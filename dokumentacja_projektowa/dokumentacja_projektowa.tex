\documentclass[12pt,a4paper,oneside]{article}

% Pakiety i konfiguracje
\RequirePackage[utf8]{inputenc}
\usepackage[QX]{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{latexsym}
\usepackage{tgpagella}
\usepackage{lmodern}
\usepackage{amsmath,amsthm,amsfonts,amssymb,alltt}
\usepackage{epsfig}
\usepackage{pdflscape}
\usepackage{caption}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{listings}
\usepackage{tocloft}
\usepackage[polish]{babel}
\usepackage{datetime2}
\usepackage[x11names,dvipsnames,table]{xcolor}
\usepackage{hyperref}
\usepackage{underscore}
\usepackage{tikz}
\usepackage[linesnumbered,lined,commentsnumbered]{algorithm2e}
\usepackage{geometry}
\tolerance=1000
\hyphenpenalty=500

% Konfiguracja pakietu geometry
\geometry{
    a4paper,
    top=2.5cm,
    bottom=2.5cm,
    left=1.5cm,
    right=1.5cm,
    headheight=15pt, % dla nagłówków, jeśli są
    includehead,
    includefoot
}


\lstset{
  basicstyle=\ttfamily\small, % Czcionka dla kodu
  keywordstyle=\color{blue}\bfseries, % Styl dla słów kluczowych
  commentstyle=\color{gray}, % Styl dla komentarzy
  stringstyle=\color{red}, % Styl dla ciągów znaków
  breaklines=true, % Łamanie linii
  breakatwhitespace=true, % Łamanie linii w miejscu spacji
  frame=single, % Ramka wokół kodu
  captionpos=b, % Pozycja podpisu (b = poniżej)
  numbers=left, % Numery linii po lewej stronie
  numberstyle=\tiny\color{gray}, % Styl numerów linii
  showstringspaces=false, % Ukrywanie spacji w ciągach znaków
  escapeinside={(*@}{@*)}, % Używanie LaTeX w kodzie
}

% Konfiguracja listowania kodu HTML
\lstset{
  language=HTML, % Ustawienie języka na HTML
  basicstyle=\ttfamily\small, % Czcionka
  keywordstyle=\color{blue}\bfseries, % Kolor słów kluczowych
  commentstyle=\color{gray}, % Kolor komentarzy
  stringstyle=\color{red}, % Kolor ciągów znaków
  breaklines=true, % Łamanie linii
  breakatwhitespace=true, % Łamanie linii w miejscu spacji
  frame=single, % Ramka wokół kodu
  captionpos=b, % Podpis pod kodem
  numbers=left, % Numery linii po lewej
  numberstyle=\tiny\color{gray}, % Styl numerów linii
  showstringspaces=false, % Ukrywanie spacji w ciągach znaków
  escapeinside={(*@}{@*)} % Używanie LaTeX w listingu
}

% Specyficzne ustawienia dla języka Python
\lstdefinelanguage{Python}{
  keywords={def, return, if, elif, else, try, except, import, from, as, pass, break, continue, lambda, with, assert},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={self, True, False, None},
  ndkeywordstyle=\color{teal}\bfseries,
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]\#,
  morecomment=[s]{"""}{"""},
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  morestring=[b]',
  morestring=[b]"
}

% Specyficzne ustawienia dla języka JavaScript
\lstdefinelanguage{JavaScript}{
    keywords={var, let, const, if, else, for, while, do, break, continue, return, switch, case, default, function, this, new, try, catch, finally, throw, class, extends, import, export, default, super, debugger},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={null, true, false, console, window, document},
    ndkeywordstyle=\color{teal}\bfseries,
    identifierstyle=\color{black},
    sensitive=true,
    comment=[l]//,
    morecomment=[s]{/*}{*/},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    morestring=[b]`,
    morestring=[b]"
}


% Konfiguracja hyperref
\hypersetup{
    pdfauthor={Roman Czapla, Olaf Bar},
    colorlinks=True,
    linkcolor=darkgray,
    citecolor=BrickRed,
    filecolor=Magenta,
    urlcolor=BlueViolet
}

% Diagramy i algorytmy
\usetikzlibrary{positioning,arrows,chains,fit,shapes,calc}
\tikzset{main node/.style={circle,fill=blue!20,draw,minimum size=1cm,inner sep=0pt}}
\SetKwFor{ForEach}{for each}{do}{end for}%
\SetKwFor{ForAll}{for all}{do}{end for}%
\newenvironment{myalgorithm}
{\rule{\textwidth}{0.5mm}\\\SetAlCapSty{}\SetAlgoNoEnd\SetAlgoNoLine\begin{algorithm}}{\end{algorithm}\rule{\textwidth}{0.5mm}}

% Konfiguracja caption
\captionsetup{
    width=.95\linewidth,
    justification=centering
}

% Definicje matematyczne
\newtheorem{tw}{Twierdzenie}[section]
\newtheorem{lem}[tw]{Lemat}
\newtheorem{co}[tw]{Wniosek}
\newtheorem{prop}[tw]{Stwierdzenie}
\theoremstyle{definition}
\newtheorem{ex}{Przykład}
\newtheorem{re}[tw]{Uwaga}
\newtheorem{de}{Definicja}[section]

% Nowe komendy
\renewcommand{\lstlistlistingname}{Lista Fragmentów Kodów}
\newcommand{\bC}{{\mathbb C}}
\newcommand{\bR}{{\mathbb R}}
\newcommand{\bZ}{{\mathbb Z}}
\newcommand{\bQ}{{\mathbb Q}}
\newcommand{\bN}{{\mathbb N}}
\newcommand{\captionT}[1]{\caption{\textsc{\footnotesize{#1}}}}
\renewcommand\figurename{Rys.}
\numberwithin{equation}{section}
\renewcommand{\thefootnote}{\arabic{footnote})}

\begin{document}
\renewcommand{\thepage}{\arabic{page}}
% --------------------------------------------
% Strona tytułowa
% --------------------------------------------

\thispagestyle{empty} % Ustawienie pustego stylu dla strony tytułowej
\begin{titlepage}
\begin{center}\Large
Uniwersytet Komisji Edukacji Narodowej w Krakowie\\
\large
Instytut Bezpieczeństwa i Informatyki\\
\vskip 10pt
\end{center}
\begin{center}
\centering \includegraphics[width=1.0\columnwidth]{images/logo.png}
\end{center}

\begin{center}
 {\bf \fontsize{14pt}{14pt}\selectfont PROJEKT INŻYNIERSKI \\ DOKUMENTACJA PROJEKTOWA}
\end{center}
\vskip 5pt
\begin{center}
 {\bf \fontsize{15pt}{25pt}\selectfont System rekomendacji produktów. Tworzenie algorytmu rekomendacyjnego na
 podstawie preferencji użytkowników – aplikacja przeglądarkowa}
\end{center}

\begin{center}
 {\fontsize{12pt}{12pt}\selectfont wykonany przez: }
\end{center}
\begin{center}
 {\bf\fontsize{16pt}{16pt}\selectfont Grzegorz x}\\
 {\fontsize{12pt}{12pt}\selectfont Nr albumu:  xxxx \\\&\\}
 {\bf\fontsize{16pt}{16pt}\selectfont Krzysztof x }\\
 {\fontsize{12pt}{12pt}\selectfont Nr albumu: x \\\&\\}
 {\bf\fontsize{16pt}{16pt}\selectfont Maciej x }\\
 {\fontsize{12pt}{12pt}\selectfont Nr albumu: x}
\end{center}
\begin{center}
 {\fontsize{12pt}{12pt}\selectfont pod opieką:}\\
 {\bf\fontsize{12pt}{12pt}\selectfont dr hab. inż.x x  }
\end{center}

\vspace*{\fill} % Dostosowanie dopełnienia do końca strony
\begin{center}
\large
Kraków \the\year\\
(ostatnia aktualizacja: \DTMcurrenttime,\;\today)
\end{center}
\end{titlepage}

\clearpage %

\tableofcontents


\newpage

\section{Szczegółowa dokumentacja projektowa}
\textit{W zależności od specyfiki projektu! Wymienione niżej podpunkty mają charakter orientacyjny.}
\subsection{Projekt UML}
\textit{W szczególności: diagram klas, ew. np. przypadki użycia, diagramy sekwencji, czynności, stanów, obiektów/komponentów/pakietów itp.}
\begin{center}
\centering \includegraphics[width=1.0\columnwidth]{images/UML.jpg}
\end{center}

\subsection{Projekt bazy danych}

\subsubsection*{Tabela \texttt{Address}}
\textbf{Opis:} Przechowuje informacje o adresach użytkowników.
\begin{itemize}
    \item \texttt{street} : varchar(255) – ulica
    \item \texttt{city} : varchar(100) – miasto
    \item \texttt{postal\string_code} : varchar(20) – kod pocztowy
    \item \texttt{country} : varchar(100) – kraj
    \item \texttt{is\string_default} : bool – flaga domyślnego adresu
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Cart}}
\textbf{Opis:} Przechowuje informacje o koszykach zakupowych.
\begin{itemize}
    \item \texttt{created\string_at} : datetime – data utworzenia koszyka
    \item \texttt{updated\string_at} : datetime – data ostatniej aktualizacji
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{CartItem}}
\textbf{Opis:} Przechowuje informacje o produktach w koszyku.
\begin{itemize}
    \item \texttt{quantity} : integer unsigned – ilość produktu
    \item \texttt{added\string_at} : datetime – data dodania produktu
    \item \texttt{cart\string_id} : bigint (klucz obcy do \texttt{Cart})
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Category}}
\textbf{Opis:} Przechowuje informacje o kategoriach produktów.
\begin{itemize}
    \item \texttt{name} : varchar(100) – nazwa kategorii
    \item \texttt{description} : text – opis kategorii
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Category\string_parent}}
\textbf{Opis:} Definiuje relacje hierarchiczne między kategoriami.
\begin{itemize}
    \item \texttt{from\string_category\string_id} : bigint (klucz obcy do \texttt{Category})
    \item \texttt{to\string_category\string_id} : bigint (klucz obcy do \texttt{Category})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Conversation}}
\textbf{Opis:} Przechowuje informacje o rozmowach.
\begin{itemize}
    \item \texttt{created\string_at} : datetime – data utworzenia rozmowy
    \item \texttt{is\string_admin\string_conversation} : bool – flaga rozmowy administracyjnej
    \item \texttt{order\string_id} : bigint (klucz obcy do \texttt{Order})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Conversation\string_participants}}
\textbf{Opis:} Przechowuje uczestników rozmowy.
\begin{itemize}
    \item \texttt{conversation\string_id} : bigint (klucz obcy do \texttt{Conversation})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Message}}
\textbf{Opis:} Przechowuje wiadomości w rozmowach.
\begin{itemize}
    \item \texttt{content} : text – treść wiadomości
    \item \texttt{timestamp} : datetime – znacznik czasu wiadomości
    \item \texttt{is\string_read} : bool – flaga odczytania wiadomości
    \item \texttt{conversation\string_id} : bigint (klucz obcy do \texttt{Conversation})
    \item \texttt{sender\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Order}}
\textbf{Opis:} Przechowuje informacje o zamówieniach.
\begin{itemize}
    \item \texttt{status} : varchar(20) – status zamówienia
    \item \texttt{previous\string_status} : varchar(20) – poprzedni status
    \item \texttt{created\string_at} : datetime – data utworzenia
    \item \texttt{total\string_amount} : decimal – łączna kwota
    \item \texttt{delivery\string_address\string_id} : bigint (klucz obcy do \texttt{Address})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{payment\string_method\string_id} : bigint (klucz obcy do \texttt{PaymentMethod})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{PaymentMethod}}
\textbf{Opis:} Przechowuje informacje o metodach płatności.
\begin{itemize}
    \item \texttt{payment\string_method} : varchar(20) – typ metody
    \item \texttt{card\string_number} : varchar(16) – numer karty
    \item \texttt{expiration\string_date} : varchar(5) – data ważności
    \item \texttt{cvv} : varchar(4) – kod CVV
    \item \texttt{blik\string_code} : varchar(6) – kod Blik
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Product}}
\textbf{Opis:} Przechowuje informacje o produktach.
\begin{itemize}
    \item \texttt{name} : varchar(100) – nazwa produktu
    \item \texttt{brand} : varchar(100) – marka produktu
    \item \texttt{image} : varchar(100) – obraz produktu
    \item \texttt{description} : text – opis produktu
    \item \texttt{price} : decimal – cena produktu
    \item \texttt{average\string_rate} : decimal – średnia ocena
    \item \texttt{product\string_details} : text – szczegóły produktu
    \item \texttt{product\string_images\string_links} : text – linki do zdjęć
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Order\string_products}}
\textbf{Opis:} Przechowuje informacje o produktach w zamówieniach.
\begin{itemize}
    \item \texttt{order\string_id} : bigint (klucz obcy do \texttt{Order})
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Product\string_categories}}
\textbf{Opis:} Przechowuje relacje między produktami a kategoriami.
\begin{itemize}
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{category\string_id} : bigint (klucz obcy do \texttt{Category})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Product\string_liked\string_by}}
\textbf{Opis:} Przechowuje informacje o użytkownikach, którzy polubili produkty.
\begin{itemize}
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{RecommendedProducts}}
\textbf{Opis:} Przechowuje listy rekomendowanych produktów.
\begin{itemize}
    \item \texttt{added\string_at} : datetime – data dodania listy
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{RecommendedProducts\string_products}}
\textbf{Opis:} Przechowuje produkty powi\k{a}zane z rekomendacjami.
\begin{itemize}
    \item \texttt{RecommendedProducts\string_id} : bigint (klucz obcy do \texttt{RecommendedProducts})
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{User\string_groups}}
\textbf{Opis:} Przechowuje relacje między użytkownikami a grupami.
\begin{itemize}
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{group\string_id} : integer (klucz obcy do \texttt{Auth\string_group})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{UserCategoryVisibility}}
\textbf{Opis:} Przechowuje informacje o widoczności kategorii dla użytkowników.
\begin{itemize}
    \item \texttt{view\string_date} : datetime – data widoczności
    \item \texttt{category\string_id} : bigint (klucz obcy do \texttt{Category})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{UserQueryLog}}
\textbf{Opis:} Przechowuje zapytania wykonane przez użytkowników.
\begin{itemize}
    \item \texttt{query} : varchar(255) – treść zapytania
    \item \texttt{query\string_date} : datetime – data zapytania
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Profile}}
\textbf{Opis:} Przechowuje informacje o profilach użytkowników.
\begin{itemize}
    \item \texttt{last\string_opened\string_conversation\string_id} : bigint (klucz obcy do \texttt{Conversation})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Rate}}
\textbf{Opis:} Przechowuje oceny produktów wystawione przez użytkowników.
\begin{itemize}
    \item \texttt{value} : integer – wartość oceny
    \item \texttt{comment} : text – komentarz do oceny
    \item \texttt{created\string_at} : datetime – data wystawienia oceny
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{Reaction}}
\textbf{Opis:} Przechowuje reakcje użytkowników na produkty.
\begin{itemize}
    \item \texttt{assigned\string_date} : datetime – data przypisania reakcji
    \item \texttt{type} : varchar(10) – typ reakcji (np. „like” lub „dislike”)
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{UserProductVisibility}}
\textbf{Opis:} Przechowuje informacje o widoczności produktów dla użytkowników.
\begin{itemize}
    \item \texttt{view\string_date} : datetime – data widoczności
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{UserRecommendedProductInteraction}}
\textbf{Opis:} Przechowuje informacje o interakcjach użytkowników z rekomendowanymi produktami.
\begin{itemize}
    \item \texttt{interaction\string_type} : varchar(20) – typ interakcji (np. kliknięcie, zakup)
    \item \texttt{interaction\string_date} : datetime – data interakcji
    \item \texttt{product\string_id} : bigint (klucz obcy do \texttt{Product})
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{User\string_user\string_permissions}}
\textbf{Opis:} Przechowuje informacje o uprawnieniach użytkowników.
\begin{itemize}
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{permission\string_id} : integer (klucz obcy do \texttt{Auth\string_permission})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}

\subsubsection*{Tabela \texttt{User\string_query\string_log}}
\textbf{Opis:} Przechowuje zapytania wyszukiwania wykonane przez użytkowników.
\begin{itemize}
    \item \texttt{query} : varchar(255) – treść zapytania
    \item \texttt{query\string_date} : datetime – data zapytania
    \item \texttt{user\string_id} : bigint (klucz obcy do \texttt{User})
    \item \texttt{id} : integer (klucz główny)
\end{itemize}


\section*{Relacje między tabelami}
\begin{itemize}
    \item \texttt{Address.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{Cart.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{CartItem.cart\string_id} $\to$ \texttt{Cart.id}
    \item \texttt{CartItem.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Category\string_parent.from\string_category\string_id} $\to$ \texttt{Category.id}
    \item \texttt{Category\string_parent.to\string_category\string_id} $\to$ \texttt{Category.id}
    \item \texttt{Conversation.order\string_id} $\to$ \texttt{Order.id}
    \item \texttt{Conversation\string_participants.conversation\string_id} $\to$ \texttt{Conversation.id}
    \item \texttt{Conversation\string_participants.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{Message.conversation\string_id} $\to$ \texttt{Conversation.id}
    \item \texttt{Message.sender\string_id} $\to$ \texttt{User.id}
    \item \texttt{Order\string_products.order\string_id} $\to$ \texttt{Order.id}
    \item \texttt{Order\string_products.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Product\string_categories.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Product\string_categories.category\string_id} $\to$ \texttt{Category.id}
    \item \texttt{Product\string_liked\string_by.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Product\string_liked\string_by.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{RecommendedProducts\string_products.recommendedproducts\string_id} $\to$ \texttt{RecommendedProducts.id}
    \item \texttt{RecommendedProducts\string_products.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{User\string_groups.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{UserCategoryVisibility.category\string_id} $\to$ \texttt{Category.id}
    \item \texttt{Profile.last\string_opened\string_conversation\string_id} $\to$ \texttt{Conversation.id}
    \item \texttt{Rate.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Rate.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{Reaction.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{Reaction.user\string_id} $\to$ \texttt{User.id}
    \item \texttt{UserRecommendedProductInteraction.product\string_id} $\to$ \texttt{Product.id}
    \item \texttt{UserRecommendedProductInteraction.user\string_id} $\to$ \texttt{User.id}
\end{itemize}


\subsubsection*{Przykładowe procedury składowane}

\subsubsection*{Dodawanie nowego użytkownika}
\begin{verbatim}
CREATE OR REPLACE PROCEDURE add_user(
    p_username VARCHAR,
    p_email VARCHAR,
    p_password VARCHAR
)
BEGIN
    INSERT INTO User (username, email, password)
    VALUES (p_username, p_email, p_password);
END;
\end{verbatim}

\subsubsection*{Pobieranie zamówień użytkownika}
\begin{verbatim}
CREATE OR REPLACE FUNCTION get_user_orders(p_user_id INT)
RETURNS TABLE(order_id INT, order_date DATETIME, status VARCHAR)
BEGIN
    RETURN QUERY
    SELECT id, order_date, status
    FROM Order
    WHERE user_id = p_user_id;
END;
\end{verbatim}

\clearpage
\subsection{Szczegółowa dokumentacja kodu}
Poniżej przedstawiono szczegółową dokumentację dotyczącą implementacji aplikacji. Dokumentacja obejmuje:
\begin{itemize}
\item \textit{opis najważniejszych zmiennych;}
\item \textit{specyfikacja i opis wszystkich klas (jeśli projekt obiektowy) - opis całej klasy, jej pól i metod (jak poniżej);}
\item \textit{opis funkcji oraz metod klas (co robią, opis poszczególnych parametrów wejściowych i zwracanych wartości itp.) oraz w przypadku bibliotek programistycznych - przykłady użycia (przykładowy kod);} 
\item \textit{opis użytych wzorców projektowych.}
\end{itemize}
% User Model details documentation 
\subsubsection{Model \texttt{User}}
\textbf{Opis:} 
Model \texttt{User} rozszerza wbudowany model \texttt{AbstractUser} i przechowuje informacje o użytkownikach systemu, takie jak dane personalne, datę rejestracji, numer telefonu oraz płeć. Wprowadza dodatkowe pola, które uzupełniają funkcjonalności dziedziczone z \texttt{AbstractUser}.

\textbf{Pola dodane w modelu \texttt{User}:}
\begin{itemize}
    \item \texttt{email}: \texttt{EmailField} – unikalny adres e-mail użytkownika (nadpisuje pole z \texttt{AbstractUser}).
    \item \texttt{birthday}: \texttt{DateField} – data urodzenia użytkownika (opcjonalne).
    \item \texttt{registration\_date}: \texttt{DateTimeField} – data rejestracji użytkownika (domyślnie ustawiana na bieżącą datę i czas).
    \item \texttt{phone\_number}: \texttt{CharField} – numer telefonu użytkownika (wymagane, maksymalnie 15 znaków).
    \item \texttt{is\_admin}: \texttt{BooleanField} – flaga wskazująca, czy użytkownik jest administratorem.
    \item \texttt{gender}: \texttt{CharField} – płeć użytkownika, wybierana spośród wartości:
    \begin{itemize}
        \item \texttt{Male}
        \item \texttt{Female}
        \item \texttt{Other}
    \end{itemize}
\end{itemize}

\textbf{Pola dziedziczone z modelu \texttt{AbstractUser}:}
\begin{itemize}
    \item \texttt{password}: \texttt{CharField} – hasło użytkownika (zabezpieczone poprzez funkcję \texttt{set\_password}).
    \item \texttt{last\_login}: \texttt{DateTimeField} – data ostatniego logowania użytkownika.
    \item \texttt{is\_superuser}: \texttt{BooleanField} – flaga oznaczająca, czy użytkownik jest superużytkownikiem.
    \item \texttt{username}: \texttt{CharField} – unikalna nazwa użytkownika.
    \item \texttt{first\_name}: \texttt{CharField} – imię użytkownika.
    \item \texttt{last\_name}: \texttt{CharField} – nazwisko użytkownika.
    \item \texttt{is\_staff}: \texttt{BooleanField} – flaga wskazująca, czy użytkownik ma uprawnienia do panelu administracyjnego.
    \item \texttt{is\_active}: \texttt{BooleanField} – flaga wskazująca, czy konto użytkownika jest aktywne.
    \item \texttt{date\_joined}: \texttt{DateTimeField} – data utworzenia konta użytkownika.
\end{itemize}

\subsubsection*{Metody modelu}
\begin{itemize}
    \item \texttt{\_\_str\_\_(self)}:
    \begin{itemize}
        \item \textbf{Opis:} Zwraca czytelną reprezentację użytkownika w formacie: \\
        \texttt{User <imie> <nazwisko> <email> \ Gender: <płeć>}.
        \item \textbf{Przykład:}
        \begin{lstlisting}
    user = User.objects.get(id=1)
    print(user)  # Output: User John Doe john.doe@example.com Gender: Male
        \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsubsection*{Formularze związane z modelem}

\paragraph{Formularz rejestracji (\texttt{UserRegistrationForm})}

\begin{itemize}
    \item \textbf{Opis:} Formularz umożliwiający rejestrację nowego użytkownika w systemie.
    \item \textbf{Pola:} 
    \begin{itemize}
        \item \texttt{first\_name}, \texttt{last\_name}, \texttt{email}, \texttt{phone\_number}, \texttt{birthday}, \texttt{gender}, \texttt{password}.
    \end{itemize}
    % Metody walidacji 
    \subsubsection*{Metody walidacji formularza}
    \begin{itemize}
        %  Metoda clean_email
        \item \texttt{clean\_email}
        \begin{itemize}
            \item \textbf{Opis:} Sprawdza, czy adres e-mail jest unikalny i należy do poprawnej domeny.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Kod metody clean\_email]
def clean_email(self):
    email = self.cleaned_data.get("email")
    if User.objects.filter(email=email).exists():
        raise forms.ValidationError(f"Email is already taken")
    elif "@" in email:
        domain = email.split("@")[1]
        if domain.split(".")[-1] not in POSSIBLE_EMAIL_DOMAIN_TLD:
            raise forms.ValidationError("Given email domain not recognized")
    return email
        \end{lstlisting}
        \item \textbf{Przykład:}
        \begin{verbatim}
Input: email = "invalid_domain@fake_domain.notreal"
Output: ValidationError: "Given email domain not recognized"
            \end{verbatim}
        \end{itemize}
    
        %  Metoda clean_phone_number
        \item \texttt{clean\_phone\_number}
        \begin{itemize}
            \item \textbf{Opis:} Upewnia się, że numer telefonu zawiera dokładnie 9 cyfr.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Kod metody clean\_phone\_number]
def clean_phone_number(self):
    phone_number = self.cleaned_data.get("phone_number")
    parsed_phone_number = re.sub(r'\D', '', phone_number)
    if len(parsed_phone_number) != 9:
        raise ValidationError("Phone number must have exactly 9 digits.")
    return parsed_phone_number
        \end{lstlisting}
        \item \textbf{Przykład:}
        \begin{verbatim}
Input: phone_number = "+48 123-456-789"
Output: "123456789"
            \end{verbatim}
        \end{itemize}
    \end{itemize}
\clearpage % mowing to other page 
    \item \textbf{Metody:}
    \item \texttt{generate\_username(first\_name, last\_name)}
    \begin{itemize}
        \item \textbf{Opis:} Generuje unikalną nazwę użytkownika na podstawie imienia i nazwiska. Jeśli istnieje już użytkownik o takiej nazwie, metoda dodaje liczbę do nazwy, aby zapewnić jej unikalność.
        \item \textbf{Kod:}
        \begin{lstlisting}[language=Python, caption=Kod metody generate\_username]
@staticmethod
def generate_username(first_name, last_name):
    first_name = first_name.lower()
    last_name = last_name.lower()

    if " " in first_name:
        first_name = "_".join(first_name.split())
    if " " in last_name:
        last_name = "_".join(last_name.split())

    username = f"{first_name}.{last_name}"
    num = 1

    while User.objects.filter(username=username).exists():
        username = f"{first_name}.{last_name}{num}"
        num += 1

    return username
        \end{lstlisting}
        \item \textbf{Przykład:}
        \begin{verbatim}
    Input: first_name = "John", last_name = "Doe"
    Output: "john.doe"

    Input: first_namqe = "John", last_name = "Doe" (if "john.doe" already exists)
    Output: "john.doe1"
        \end{verbatim}
    \end{itemize}
\end{itemize}

% \clearpage % mowing to other page 
\paragraph{Formularz logowania (\texttt{UserLoginForm})}

\begin{itemize}
    \item \textbf{Opis:} Formularz umożliwiający logowanie użytkownika na podstawie adresu e-mail i hasła.
    \item \textbf{Pola:}
    \begin{itemize}
        \item \texttt{email}, \texttt{password}.
    \end{itemize}
\end{itemize}

\subsubsection*{Widoki związane z modelem}

\paragraph{\texttt{UserRegisterView}}
\begin{itemize}
    \item \textbf{Opis:} Widok umożliwiający użytkownikom rejestrację w systemie.
    \item \textbf{Atrybuty:}
    \begin{itemize}
        \item \texttt{template\_name}: Ścieżka do szablonu używanego dla rejestracji (\texttt{"registration/register.html"}). 
        Kod szablonu został szczegółowo opisany w sekcji \ref{sec:register_template}.
        \item \texttt{form\_class}: Formularz używany w widoku rejestracji (\texttt{UserRegistrationForm}).
        \item \texttt{success\_url}: URL, na który użytkownik jest przekierowywany po pomyślnej rejestracji (\texttt{"login"}).
    \end{itemize}
    \item \textbf{Metody:}
    \begin{itemize}
        \item \texttt{form\_valid(self, form)}:
        \begin{itemize}
            \item \textbf{Opis:} Obsługuje poprawne przesłanie formularza rejestracji.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Metoda form\_valid w UserRegisterView]
def form_valid(self, form):
    form.save(commit=True)
    messages.success(self.request, "Registered successfully")
    send_registration_email(form.cleaned_data['email'], form.cleaned_data['first_name'])
    return super().form_valid(form)
            \end{lstlisting}
            \item \textbf{Wyjaśnienie:}
            \begin{itemize}
                \item Zapisuje nowego użytkownika w bazie danych.
                \item Wyświetla komunikat o sukcesie przy użyciu systemu wiadomości Django.
                \item Wysyła e-mail z potwierdzeniem rejestracji na adres użytkownika.  (szczegóły funkcji \texttt{send\_registration\_email} w sekcji \ref{sec:helper_functions}).
            \end{itemize}
        \end{itemize}
        \item \texttt{form\_invalid(self, form)}:
        \begin{itemize}
            \item \textbf{Opis:} Obsługuje niepoprawne przesłanie formularza.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Metoda form\_invalid w UserRegisterView]
def form_invalid(self, form):
    return super().form_invalid(form)
            \end{lstlisting}
            \item \textbf{Wyjaśnienie:}
            \begin{itemize}
                \item Przekazuje niepoprawny formularz do szablonu w celu wyświetlenia błędów.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}

\paragraph{\texttt{UserLoginView}}
\begin{itemize}
    \item \textbf{Opis:} Widok umożliwiający logowanie użytkownika.
    \item \textbf{Atrybuty:}
    \begin{description}
        \item[\texttt{template\_name}] Ścieżka do szablonu logowania (\texttt{"registration/login.html"}).\\
        \hspace{1cm} Kod szablonu został szczegółowo opisany w sekcji \ref{sec:login_template}.
        \item[\texttt{form\_class}] Formularz używany w widoku logowania (\texttt{UserLoginForm}).
        \item[\texttt{success\_url}] URL, na który użytkownik jest przekierowywany po pomyślnym zalogowaniu (\texttt{"home"}).
    \end{description}
    \item \textbf{Metody:}
    \begin{itemize}
    \item \texttt{form\_valid(self, form)}:
    \begin{itemize}
        \item \textbf{Opis:} Obsługuje poprawne przesłanie formularza logowania.
        \item \textbf{Kod:}
        \begin{lstlisting}[language=Python, caption=Metoda form\_valid w UserLoginView]
def form_valid(self, form):
    email = form.cleaned_data.get('email')
    password = form.cleaned_data.get('password')
    try:
        user = User.objects.get(email=email)
        username = user.username
        user = authenticate(self.request, username=username, password=password)
        if user is not None:
            login(self.request, user)
            messages.success(self.request, "Login successfully")
            sync_session_likes_to_user(self.request)
            return super().form_valid(form)
        else:
            form.add_error(None, "Incorrect email or password")
    except User.DoesNotExist:
        form.add_error('email', "No user found with the given email address")
    return self.form_invalid(form)
            \end{lstlisting}
            \item \textbf{Wyjaśnienie:}
            \begin{itemize}
                \item Pobiera dane logowania z formularza (\texttt{email}, \texttt{password}).
                \item Wyszukuje użytkownika na podstawie adresu e-mail.
                \item Próbuje uwierzytelnić użytkownika za pomocą funkcji \texttt{authenticate}.
                \item Jeśli uwierzytelnienie powiedzie się, loguje użytkownika i wyświetla komunikat o sukcesie.
                \item Jeśli uwierzytelnienie nie powiedzie się, dodaje odpowiednie błędy do formularza.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}


\subsubsection*{Endpointy związane z modelem}

\begin{itemize}
    \item \texttt{/register/} – rejestracja użytkownika (\texttt{UserRegisterView}).
    \item \texttt{/login/} – logowanie użytkownika (\texttt{UserLoginView}).
    \item \texttt{/logout/} – wylogowanie użytkownika (\texttt{logout\_view}).
\end{itemize}

\subsubsection*{Szablony użytkownika}
\label{sec:user_templates}

\paragraph{\texttt{login.html}}
\label{sec:login_template}

Szablon odpowiedzialny za logowanie użytkownika do systemu. Poniżej przedstawiono fragment kodu HTML użytego w szablonie:

\begin{lstlisting}[language=HTML, caption=Szablon login.html]
    <form method="post" action="{% url 'login' %}">
        {% csrf_token %}
        <label for="id_email">Email:</label>
        <input type="email" name="email" id="id_email" required>
        <label for="id_password">Haslo:</label>
        <input type="password" name="password" id="id_password" required>
        <button type="submit">Zaloguj sie</button>
    </form>
\end{lstlisting}

\textbf{Wyjaśnienie:}
\begin{itemize}
    \item \texttt{method="post"}: Określa metodę przesyłania danych (HTTP POST).
    \item \texttt{{\% csrf\_token \%}}: Token zabezpieczający przed atakami CSRF (wymagany w Django).
    \item \texttt{name="email"}: Pole do wprowadzenia adresu e-mail.
    \item \texttt{name="password"}: Pole do wprowadzenia hasła użytkownika.
    \item Przycisk \texttt{submit}: Służy do przesłania formularza do widoku logowania.
\end{itemize}

\begin{figure}[H] % 'H' wymusza umieszczenie w bieżącym miejscu
    \paragraph{\texttt{register.html}}
    \label{sec:register_template}
    Szablon odpowiedzialny za rejestrację nowych użytkowników. Poniżej przedstawiono fragment kodu HTML użytego w szablonie:
    \begin{lstlisting}[language=HTML, caption=Szablon register.html]
        <form method="post" action="{% url 'register_user' %}">
            {% csrf_token %}
            <label for="id_first_name">Imie:</label>
            <input type="text" name="first_name" id="id_first_name" required>
            <label for="id_last_name">Nazwisko:</label>
            <input type="text" name="last_name" id="id_last_name" required>
            <label for="id_email">Email:</label>
            <input type="email" name="email" id="id_email" required>
            <button type="submit">Zarejestruj sie</button>
        </form>
    \end{lstlisting}
    \end{figure}

\textbf{Wyjaśnienie:}
\begin{itemize}
    \item \texttt{name="first\_name"}: Pole do wprowadzenia imienia użytkownika.
    \item \texttt{name="last\_name"}: Pole do wprowadzenia nazwiska użytkownika.
    \item \texttt{name="email"}: Pole do wprowadzenia adresu e-mail.
    \item Token CSRF i przycisk \texttt{submit}: Działają analogicznie do tych w \texttt{login.html}.
\end{itemize}

\textbf{Uwagi:}
\begin{itemize}
    \item Oba szablony korzystają z tokenu CSRF, co jest standardem w Django w celu zapewnienia bezpieczeństwa.
    \item Formularze wykorzystują prostą strukturę HTML. Rozbudowa o dodatkowe style CSS lub framework (np. Bootstrap) jest możliwa w dalszym rozwoju aplikacji.
\end{itemize}

\subsection{Funkcje pomocnicze}
\label{sec:helper_functions}

\begin{figure}[H] %
    \paragraph{\texttt{send\_registration\_email(email, user)}}
    Funkcja pomocnicza odpowiedzialna za wysyłanie e-maila potwierdzającego rejestrację użytkownika.
    \begin{lstlisting}[language=Python, caption=Funkcja send_registration_email]
    def send_registration_email(email, user):
        subject = 'Rejestracja w KMG Store'
        html_message = render_to_string('email/registration_email.html', {'user': user})
        plain_message = strip_tags(html_message)
        from_email = 'kmgstoreproject@gmail.com'
        to = email

        send_mail(subject, plain_message, from_email, [to], html_message=html_message)
    \end{lstlisting}

    \textbf{Opis działania:}
    \begin{itemize}
        \item Pobiera e-mail użytkownika oraz obiekt użytkownika jako parametry wejściowe.
        \item Generuje temat wiadomości oraz treść HTML za pomocą szablonu \texttt{registration\_email.html}.
        \item Wysyła e-mail za pomocą funkcji \texttt{send\_mail} Django.
    \end{itemize}
\end{figure}


\subsubsection*{Zastosowane wzorce projektowe}

\begin{itemize}
    \item \textbf{Wzorzec Template Method:} Widoki \texttt{UserRegisterView} i \texttt{UserLoginView} korzystają z generycznych klas widoków.
    \item \textbf{Wzorzec Factory:} Metoda \texttt{generate\_username} dynamicznie generuje nazwę użytkownika.
\end{itemize}

\clearpage %
% Model Address
\subsubsection*{Model \texttt{Address}}
\textbf{Opis:}  
Model \texttt{Address} przechowuje informacje o adresach użytkowników w systemie. Każdy adres przypisany jest do konkretnego użytkownika i może być oznaczony jako domyślny.

\paragraph{Atrybuty:}
\begin{itemize}
    \item \texttt{user}: \texttt{ForeignKey} – relacja z modelem \texttt{User}.
    \begin{itemize}
        \item \texttt{on\_delete=models.CASCADE}: Określa, co zrobić z rekordami \texttt{Address}, gdy rekord użytkownika zostanie usunięty.  
        Wartość \texttt{CASCADE} oznacza, że usunięcie użytkownika spowoduje usunięcie wszystkich powiązanych z nim adresów.
        \item \texttt{related\_name='addresses'}: Umożliwia odwołanie się do wszystkich adresów użytkownika za pomocą \texttt{user.addresses} w zapytaniach Django ORM.
    \end{itemize}
    \item \texttt{street}: \texttt{CharField} (max. 255 znaków) – ulica.
    \item \texttt{city}: \texttt{CharField} (max. 100 znaków) – miasto.
    \item \texttt{postal\_code}: \texttt{CharField} (max. 20 znaków) – kod pocztowy.
    \item \texttt{country}: \texttt{CharField} (max. 100 znaków) – kraj.
    \item \texttt{is\_default}: \texttt{BooleanField} – flaga oznaczająca, czy adres jest domyślny (domyślnie: \texttt{False}).
\end{itemize}


\paragraph{Metody:}
\begin{itemize}
    \item \texttt{get\_address(self)}  
        \begin{itemize}
            \item \textbf{Opis:} Zwraca pełny adres w formie łańcucha tekstowego.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Metoda get\_address w modelu Address]
def get_address(self):
    return f"{self.street}, {self.city}, {self.country}"
            \end{lstlisting}
        \end{itemize}
    \item \texttt{\_\_str\_\_(self)}  
        \begin{itemize}
            \item \textbf{Opis:} Zwraca reprezentację tekstową obiektu \texttt{Address}.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Metoda \_\_str\_\_ w modelu Address]
def __str__(self):
    return f"{self.street}, {self.city}, {self.country} ({self.user.email})"
            \end{lstlisting}
        \end{itemize}
\end{itemize}

\subsubsection*{Formularz \texttt{UserAddressForm}}
\textbf{Opis:}  
Formularz pozwalający użytkownikom na wprowadzanie i edycję adresów.

\paragraph{Atrybuty:}
\begin{itemize}
    \item \texttt{fields}: Lista pól formularza: \texttt{street}, \texttt{city}, \texttt{postal\_code}, \texttt{country}, \texttt{is\_default}.
    \item \texttt{widgets}: Niestandardowe widżety dla pól, np. \texttt{TextInput} dla pól tekstowych i \texttt{CheckboxInput} dla pola \texttt{is\_default}.
    \item \texttt{labels}: Etykieta dla pola \texttt{is\_default}: \texttt{"Ustaw jako domyślny adres"}.
\end{itemize}

\paragraph{Walidacja:}
\begin{itemize}
    \item \texttt{clean(self)}  
        \begin{itemize}
            \item \textbf{Opis:} Sprawdza, czy wszystkie wymagane pola zostały poprawnie wypełnione.
            \item \textbf{Kod:}
            \begin{lstlisting}[language=Python, caption=Walidacja formularza UserAddressForm]
def clean(self):
    cleaned_data = super().clean()
    if not cleaned_data.get('street'):
        self.add_error('street', "Ulica jest wymagana.")
    if not cleaned_data.get('city'):
        self.add_error('city', "Miasto jest wymagane.")
    if not cleaned_data.get('postal_code'):
        self.add_error('postal_code', "Kod pocztowy jest wymagany.")
    if not cleaned_data.get('country'):
        self.add_error('country', "Kraj jest wymagany.")
    return cleaned_data
            \end{lstlisting}
        \end{itemize}
\end{itemize}

\paragraph{\texttt{UserAddressCreationView}}
\vspace{0.5em}
\textbf{Opis:} Widok umożliwiający użytkownikowi dodanie nowego adresu dostawy. \\
\textbf{Szablon:} \texttt{add\_address.html} \\
(szczegółowo opisany w sekcji \ref{sec:add_address_template}). \\
\vspace{0.5em}
\textbf{Działanie:}
\begin{itemize}
    \item Pobiera dane z formularza \texttt{UserAddressForm} i zapisuje je w bazie danych.
    \item Jeżeli użytkownik zaznaczy opcję ustawienia adresu jako domyślnego, wszystkie inne adresy użytkownika są automatycznie oznaczane jako niedomyślne.
    \item Po pomyślnym dodaniu adresu użytkownik jest przekierowywany na stronę wyboru adresu (\texttt{address\_selection.html}).
    \item Wyświetla komunikat o powodzeniu operacji.
\end{itemize}

\textbf{Główne metody:}
\begin{itemize}
    \item \texttt{form\_valid(self, form)}:
    \begin{itemize}
        \item Obsługuje poprawne przesłanie formularza.
        \item Kod:
        \begin{lstlisting}[language=Python, caption=Metoda \texttt{form\_valid} w \texttt{UserAddressCreationView}]
def form_valid(self, form):
    address = form.save(commit=False)
    address.user = self.request.user

    if form.cleaned_data.get('is_default'):
        Address.objects.filter(user=self.request.user, is_default=True).update(is_default=False)
        address.is_default = True

    address.save()
    messages.success(self.request, f"Adres {address.street} zostal zapisany.")
    return super().form_valid(form)
        \end{lstlisting}
    \item \textbf{Działanie:}
    \begin{itemize}
        \item Tworzy nowy adres powiązany z użytkownikiem.
        \item Obsługuje ustawianie adresu jako domyślnego.
        \item Przekazuje komunikaty sukcesu.
    \end{itemize}
    \end{itemize}
    \item \texttt{get\_context\_data(self, **kwargs)}:
    \begin{itemize}
        \item Generuje dynamiczne pola formularza dla \texttt{add\_address.html}.
    \end{itemize}
\end{itemize}

\paragraph{\texttt{AddressSelectionView}}
\textbf{Opis:} Widok umożliwiający użytkownikowi wybór adresu dostawy spośród zapisanych adresów.  
\textbf{Szablon:} \texttt{address\_selection.html} (szczegółowo opisany w sekcji \ref{sec:address_selection_template}).  
\textbf{Działanie:}
\begin{itemize}
    \item Wyświetla listę adresów użytkownika w formie opcji do wyboru.
    \item Pozwala użytkownikowi oznaczyć adres jako domyślny.
    \item Jeżeli użytkownik nie ma zapisanych adresów, przekierowuje go do widoku dodawania nowego adresu.
    \item Po zatwierdzeniu wyboru użytkownik jest przekierowywany do metody płatności (\texttt{payment\_form.html}).
\end{itemize}
\textbf{Główne metody:}
\begin{itemize}
    \item \texttt{get(self, request, *args, **kwargs)}:
    \begin{itemize}
        \item Pobiera wszystkie adresy użytkownika.
        \item Oznacza adres domyślny, jeśli taki istnieje.
        \item Kod:
        \begin{lstlisting}[language=Python, caption=Metoda \texttt{get} w \texttt{AddressSelectionView}]
def get(self, request, *args, **kwargs):
    user_addresses = Address.objects.filter(user=request.user)

    if not user_addresses.exists():
        messages.info(request, "Nie masz jeszcze zapisanych adresow. Dodaj nowy adres.")
        return redirect('add_address')

    default_address = user_addresses.filter(is_default=True).first()
    context = {
        'addresses': user_addresses,
        'default_address_id': default_address.id if default_address else None,
    }
    return render(request, self.template_name, context)
        \end{lstlisting}
    \item \textbf{Działanie:}
    \begin{itemize}
        \item Przekazuje listę adresów użytkownika do szablonu.
        \item Obsługuje brak adresów, wyświetlając komunikat i przekierowując użytkownika do dodania nowego adresu.
    \end{itemize}
    \end{itemize}
    \item \texttt{post(self, request, *args, **kwargs)}:
    \begin{itemize}
        \item Umożliwia użytkownikowi wybór domyślnego adresu.
        \item Kod:
        \begin{lstlisting}[language=Python, caption=Metoda \texttt{post} w \texttt{AddressSelectionView}]
def post(self, request, *args, **kwargs):
    selected_address_id = request.POST.get('selected_address')

    if selected_address_id:
        Address.objects.filter(user=request.user, is_default=True).update(is_default=False)
        Address.objects.filter(id=selected_address_id, user=request.user).update(is_default=True)

        messages.success(request, "Adres zostal zapisany.")
        return redirect('payment_form')

    messages.error(request, "Prosze wybrac adres dostawy.")
    return redirect('address_selection')
        \end{lstlisting}
    \item \textbf{Działanie:}
    \begin{itemize}
        \item Oznacza wybrany adres jako domyślny.
        \item Przekazuje użytkownika do metody płatności.
    \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection*{Szablony użytkownika}

\paragraph{\texttt{add\_address.html}}
\label{sec:add_address_template}
Szablon umożliwiający dodanie nowego adresu użytkownika.  
\textbf{Działanie:}
\begin{itemize}
    \item Formularz umożliwia użytkownikowi wprowadzenie danych adresowych, takich jak ulica, miasto, kod pocztowy i kraj.
    \item Opcjonalnie użytkownik może oznaczyć adres jako domyślny.
    \item Przyciski nawigacyjne pozwalają zapisać adres lub powrócić do poprzedniego widoku.
\end{itemize}
\textbf{Kod szablonu:}
\begin{lstlisting}[language=HTML, caption=Szablon add\_address.html]
<form method="post">
    {% csrf_token %}
    {% for field in form_fields %}
        <div class="form-group">
            <label for="{{ field.name }}" class="form-label">{{ field.label }}:</label>
            <input type="text" id="{{ field.name }}" name="{{ field.name }}" class="form-input"
                placeholder="{{ field.placeholder }}" required>
        </div>
    {% endfor %}
    <div class="form-group">
        <label>
            <input type="checkbox" id="is_default" name="is_default" class="form-checkbox">
            Ustaw jako domyslny adres
        </label>
    </div>
    <div class="card">
        <div class="card-body d-flex justify-content-between align-items-center">
            <a href="{% url 'cart_detail' %}"
               class="form-button form-button-secondary">Powrot</a>
            <button type="submit" class="btn proceed-button">Zapisz adres</button>
        </div>
    </div>
</form>
\end{lstlisting}

\paragraph{\texttt{address\_selection.html}}
\label{sec:address_selection_template}
Szablon umożliwiający wybór istniejącego adresu dostawy.  
\textbf{Działanie:}
\begin{itemize}
    \item Wyświetla listę zapisanych adresów użytkownika jako opcje do wyboru.
    \item Oznacza domyślny adres, jeśli istnieje.
    \item Umożliwia zapisanie wybranego adresu jako domyślnego.
    \item Przycisk nawigacyjny pozwala dodać nowy adres.
\end{itemize}
\textbf{Kod szablonu:}
\begin{lstlisting}[language=HTML, caption=Szablon address\_selection.html]
<form method="post">
    {% csrf_token %}
    {% for address in addresses %}
        <div class="address-card-wrapper {% if address.id == default_address_id %}address-default{% endif %}">
            <input type="radio" name="selected_address" value="{{ address.id }}" id="address-{{ address.id }}"
                   class="address-card-radio" {% if address.id == default_address_id %}checked{% endif %}>
            <label for="address-{{ address.id }}" class="address-card-label">
                <div class="address-card-content">
                    <p><strong>{{ address.street }}</strong></p>
                    <p>{{ address.city }}, {{ address.postal_code }}</p>
                    <p>{{ address.country }}</p>
                    {% if address.id == default_address_id %}
                        <span class="address-default-badge">Domyslny</span>
                    {% endif %}
                </div>
            </label>
        </div>
    {% endfor %}
    <div class="card">
        <div class="card-body d-flex justify-content-between align-items-center">
            <a href="{% url 'add_address' %}" class="form-button form-button-secondary">Dodaj nowy adres</a>
            <button type="submit" class="btn proceed-button">Zatwierdz adres</button>
        </div>
    </div>
</form>
<script src="../static/js/manage_address_selection.js"></script>
\end{lstlisting}





\subsubsection*{Skrypty JavaScript}

\paragraph{\texttt{manage.address\_selection.js}}
Skrypt odpowiedzialny za obsługę interakcji użytkownika z widokiem wyboru adresu dostawy.  
\textbf{Działanie:}
\begin{itemize}
    \item Obsługuje podświetlanie aktywnej opcji adresu przy kliknięciu na kartę adresu.
    \item Sprawdza, czy użytkownik wybrał adres przed wysłaniem formularza – jeżeli nie, wyświetla komunikat o konieczności wyboru adresu.
\end{itemize}

\textbf{Kod skryptu:}
\begin{lstlisting}[language=JavaScript, caption=Skrypt manage.address\_choice.js]
document.addEventListener('DOMContentLoaded', function () {
    const addressCards = document.querySelectorAll('.address-card');
    const form = document.getElementById('address-form');

    addressCards.forEach(card => {
        card.addEventListener('click', () => {
            addressCards.forEach(c => c.classList.remove('active'));
            card.classList.add('active');
        });
    });

    form.addEventListener('submit', function (event) {
        const selectedAddress = document.querySelector('input[name="selected_address"]:checked');
        if (!selectedAddress) {
            event.preventDefault();
            alert('Prosze wybrac adres dostawy.');
        }
    });
});
\end{lstlisting}


% 
% Model PaymentMethod
% 
\subsubsection{Model \texttt{PaymentMethod}}

\textbf{Opis:}  
Model \texttt{PaymentMethod} reprezentuje informacje o metodach płatności dostępnych dla użytkowników systemu. Pozwala na przechowywanie szczegółów dotyczących różnych metod płatności, takich jak karta kredytowa, Blik czy płatność za pobraniem. Model jest powiązany z użytkownikiem za pomocą relacji \texttt{ForeignKey}.

\textbf{Pola w modelu \texttt{PaymentMethod}:}
\begin{itemize}
    \item \texttt{user}: \texttt{ForeignKey} – odniesienie do modelu \texttt{User}, określające, do którego użytkownika należy metoda płatności. Relacja jest typu \texttt{CASCADE}, co oznacza, że usunięcie użytkownika powoduje usunięcie jego metod płatności.
    \item \texttt{payment\_method}: \texttt{CharField} – określa wybraną metodę płatności. Dostępne opcje to:
    \begin{itemize}
        \item \texttt{karta} – Karta kredytowa/debetowa,
        \item \texttt{blik} – Blik,
        \item \texttt{za\_pobraniem} – Płatność za pobraniem.
    \end{itemize}
    \item \texttt{card\_number}: \texttt{CharField} – numer karty płatniczej, wymagany, jeśli metoda płatności to \texttt{karta}. Maksymalna długość: 16 znaków.
    \item \texttt{expiration\_date}: \texttt{CharField} – data ważności karty w formacie MM/YY, wymagana dla \texttt{karta}. Maksymalna długość: 5 znaków.
    \item \texttt{cvv}: \texttt{CharField} – kod CVV karty płatniczej, wymagany dla \texttt{karta}. Maksymalna długość: 4 znaki.
    \item \texttt{blik\_code}: \texttt{CharField} – kod Blik, wymagany, jeśli metoda płatności to \texttt{blik}. Maksymalna długość: 6 znaków.
\end{itemize}

\textbf{Metody modelu:}
\begin{itemize}
    \item \texttt{get\_payment\_method(self)}:
    \begin{itemize}
        \item \textbf{Opis:} Zwraca nazwę wybranej metody płatności na podstawie pola \texttt{payment\_method}. Jeśli metoda jest nieznana, zwracana jest wartość \texttt{Nieznana metoda płatności}.
        \item \textbf{Przykład:}
        \begin{lstlisting}[language=Python]
payment = PaymentMethod.objects.get(id=1)
print(payment.get_payment_method())  # Output: "Karta kredytowa/debetowa"
        \end{lstlisting}
    \end{itemize}
    \item \texttt{\_\_str\_\_(self)}:
    \begin{itemize}
        \item \textbf{Opis:} Zwraca czytelną reprezentację obiektu w formacie: \texttt{<metoda\_płatności> for <nazwa\_użytkownika>}.
        \item \textbf{Przykład:}
        \begin{lstlisting}[language=Python]
payment = PaymentMethod.objects.get(id=1)
print(payment)  # Output: "karta for johndoe"
        \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsubsection*{Formularze związane z modelem}

\paragraph{Formularz wyboru metody płatności (\texttt{PaymentMethodForm})}
\begin{itemize}
    \item \textbf{Opis:} Formularz umożliwiający użytkownikowi wybór i konfigurację metody płatności.
    \item \textbf{Pola:}
    \begin{itemize}
        \item \texttt{payment\_method}, \texttt{card\_number}, \texttt{expiration\_date}, \texttt{cvv}, \texttt{blik\_code}.
    \end{itemize}
    \item \textbf{Walidacja:}
    \begin{itemize}
        \item Dla metody \texttt{karta}: \texttt{card\_number}, \texttt{expiration\_date}, \texttt{cvv} są wymagane.
        \item Dla metody \texttt{blik}: brak dodatkowych wymagań.
    \end{itemize}
\end{itemize}

\subsubsection*{Widoki związane z modelem}

\paragraph{\texttt{PaymentMethodView}}
\begin{itemize}
    \item \textbf{Opis:} Widok umożliwiający użytkownikom wybór i zapisanie metody płatności.
    \item \textbf{Atrybuty:}
    \begin{itemize}
        \item \texttt{template\_name}: \texttt{"cart\_order/payment.html"}.
        \item \texttt{form\_class}: \texttt{PaymentMethodForm}.
    \end{itemize}
    \item \textbf{Metody:}
    \begin{itemize}
        \item \texttt{form\_valid(self, form)}:
        \begin{itemize}
            \item \textbf{Opis:} Obsługuje poprawne przesłanie formularza. Zapisuje metodę płatności i przekierowuje użytkownika na odpowiednią stronę w zależności od wybranej metody.
        \end{itemize}
        \item \texttt{form\_invalid(self, form)}:
        \begin{itemize}
            \item \textbf{Opis:} Obsługuje niepoprawne przesłanie formularza, wyświetlając błędy walidacji.
        \end{itemize}
    \end{itemize}
\end{itemize}


\paragraph{\texttt{BlikCodeView}}
\begin{itemize}
    \item \textbf{Opis:} Widok obsługujący wprowadzanie kodu Blik przez użytkownika podczas finalizacji zamówienia.
    \item \textbf{Kod widoku:}
\begin{lstlisting}[language=Python, caption=Kod widoku BlikCodeView]
class BlikCodeView(CategoriesMixin, LoginRequiredMixin, View):
    template_name = "cart_order/blik_payment.html"

    def get(self, request, *args, **kwargs):
        context = self.get_context_data()
        return render(request, self.template_name, context)

    def post(self, request, *args, **kwargs):
        blik_code = request.POST.get('blik_code')

        if not blik_code or len(blik_code) != 6 or not blik_code.isdigit():
            messages.error(request, "Nieprawidlowy kod Blik. Sprobuj ponownie.")
            return render(request, self.template_name)

        # Zapisz kod Blik w sesji
        order_session = request.session.get('order_session', {})
        order_session['blik_code'] = blik_code
        request.session['order_session'] = order_session
        request.session.modified = True

        messages.success(request, "Platnosc Blik zostala zatwierdzona.")
        return redirect('create_order')
\end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
    \begin{itemize}
        \item \texttt{get(self, request, *args, **kwargs)}:
        \begin{itemize}
            \item Wyświetla stronę do wprowadzenia kodu Blik.
            \item Tworzy kontekst za pomocą \texttt{get\_context\_data}.
            \item Renderuje szablon \texttt{blik\_payment.html}.
        \end{itemize}
        \item \texttt{post(self, request, *args, **kwargs)}:
        \begin{itemize}
            \item Przetwarza kod Blik wprowadzony przez użytkownika.
            \item Sprawdza poprawność kodu:
            \begin{itemize}
                \item Kod musi mieć dokładnie 6 cyfr.
                \item Kod może zawierać tylko cyfry.
            \end{itemize}
            \item W przypadku błędu:
            \begin{itemize}
                \item Wyświetla komunikat o błędzie.
                \item Renderuje ponownie stronę z formularzem.
            \end{itemize}
            \item Jeśli kod jest poprawny:
            \begin{itemize}
                \item Zapisuje kod Blik w sesji.
                \item Przekierowuje na stronę \texttt{create\_order}.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}


\subsubsection*{Endpointy związane z modelem}
\begin{itemize}
    \item \texttt{/payment/} – wybór metody płatności (\texttt{PaymentMethodView}).
    \item \texttt{/blik-payment/} – wprowadzenie kodu Blik. (\texttt{BlikCodeView})
\end{itemize}

\subsubsection*{Szablony związane z modelem}

\paragraph{\texttt{payment.html}}
\begin{itemize}
    \item \textbf{Opis:} Formularz wyboru metody płatności z dynamicznym ukrywaniem pól dla \texttt{karta} i \texttt{blik}. Zawiera logikę JavaScript do zmiany widoczności pól na podstawie wybranej metody płatności.
\end{itemize}

\begin{lstlisting}[language=HTML, caption=Szablon payment.html]
<form method="post" action="{% url 'payment_form' %}">
    {% csrf_token %}
    <div class="form-group">
        <label for="id_payment_method" class="form-label">Wybierz metode platnosci</label>
        {{ form.payment_method|add_class:"form-select" }}
    </div>
    <div id="card-fields" class="form-group" style="display: none;">
        <div class="mb-2">
            <label for="id_card_number" class="form-label">Numer karty</label>
            {{ form.card_number|add_class:"form-input" }}
        </div>
        <div class="mb-2">
            <label for="id_expiration_date" class="form-label">Data waznosci</label>
            {{ form.expiration_date|add_class:"form-input" }}
        </div>
        <label for="id_cvv" class="form-label">CVV</label>
        {{ form.cvv|add_class:"form-input" }}
    </div>
    <div class="card">
        <div class="card-body d-flex justify-content-between align-items-center">
            <button type="submit" class="btn proceed-button">Zatwierdz platnosc</button>
        </div>
    </div>
</form>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const paymentMethodSelect = document.querySelector('#id_payment_method');
        const cardFields = document.querySelector('#card-fields');

        function updateFields() {
            const selectedMethod = paymentMethodSelect.value;
            cardFields.style.display = selectedMethod === 'karta' ? 'block' : 'none';
        }

        paymentMethodSelect.addEventListener('change', updateFields);
        updateFields(); // Initial update
    });
</script>
\end{lstlisting}

\paragraph{\texttt{blik\_payment.html}}
\begin{itemize}
    \item \textbf{Opis:} Szablon umożliwiający użytkownikowi wprowadzenie kodu Blik.
\end{itemize}

\begin{lstlisting}[language=HTML, caption=Szablon blik_payment.html]
<section class="blik-container">
    <div class="blik-wrapper">
        <div class="blik-header">
            <h2 class="blik-title">Wprowadx kod Blik</h2>
            <p class="blik-description">Aby zatwierdzic platnosc, wprowadz 6-cyfrowy kod wygenerowany w aplikacji mobilnej banku.</p>
        </div>
        <div class="blik-body">
            <form method="post" class="blik-form">
                {% csrf_token %}
                <div class="blik-form-group">
                    <label for="blik_code" class="blik-form-label">Kod Blik</label>
                    <input type="text" id="blik_code" name="blik_code" maxlength="6" class="blik-form-input"
                           placeholder="Wprowadz 6-cyfrowy kod Blik">
                </div>
                <div class="blik-form-actions">
                    <button type="submit" class="blik-submit-btn">Zatwierdz kod</button>
                </div>
            </form>
        </div>
    </div>
</section>
\end{lstlisting}

% 
% Model Product
% 
\clearpage
\subsection{Model \texttt{Product}}
\paragraph{Opis:}  Model \texttt{Product} przechowuje informacje o produktach dostępnych w sklepie internetowym, 
    takie jak: nazwa, marka, opis, cena, średnia ocena, zdjęcia oraz szczegóły techniczne.\\
    Model umożliwia również przypisanie kategorii oraz oznaczenie produktów ulubionych przez użytkowników.

\subsubsection{Pola modelu}
\begin{itemize}
    \item \texttt{name}: \texttt{CharField} – nazwa produktu (max 100 znaków).
    \item \texttt{brand}: \texttt{CharField} – nazwa marki produktu. (Domyślna wartość: \texttt{KMG}).
    \item \texttt{image}: \texttt{ImageField} – główne zdjęcie produktu.
    \item \texttt{description}: \texttt{TextField} – szczegółowy opis produktu.
    \item \texttt{price}: \texttt{DecimalField} – cena produktu.
    \item \texttt{average\_rate}: \texttt{DecimalField} – średnia ocena produktu.
    \item \texttt{liked\_by}: \texttt{ManyToManyField} – użytkownicy, którzy dodali produkt do ulubionych.
    \item \texttt{categories}: \texttt{ManyToManyField} – przypisane kategorie produktu.
    \item \texttt{product\_details}: \texttt{JSONField} – szczegóły techniczne produktu (format JSON).
    \item \texttt{product\_images\_links}: \texttt{JSONField} – dodatkowe zdjęcia produktu (format JSON).
\end{itemize}

\subsubsection{Metody modelu}
\begin{itemize}
    \item \texttt{clean(self)}:
    \begin{itemize}
        \item \textbf{Opis:} Waliduje, czy plik zdjęcia istnieje w systemie plików.
        \item \textbf{Przykład błędu:} \texttt{ValidationError: "The image default\_product.png does not exist."}
    \end{itemize}
    \item \texttt{update\_average\_rate(self)}:
    \begin{itemize}
        \item \textbf{Opis:} Przelicza i aktualizuje średnią ocenę produktu na podstawie powiązanych ocen.
    \end{itemize}
\end{itemize}

\clearpage
\subsubsection{Widoki modelu}
\paragraph{\texttt{HomePageView}}
\begin{itemize}
    \item \textbf{Opis:} Widok strony głównej prezentujący dynamicznie produkty oraz kategorie, z uwzględnieniem rekomendacji dla użytkownika lub losowych produktów.
    \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=Kod widoku HomePageView]
class HomePageView(CategoriesMixin, ListView):
    model = Product
    template_name = "homePage/index.html"
    context_object_name = "products"

    def get_favorites(self):
        return get_liked_products(self.request)

    def get_queryset(self):
        if self.request.user.is_authenticated:
            queryset = get_recommended_products(self.request.user)
            if not queryset:
                queryset = Product.objects.order_by('?')[:10]
        else:
            queryset = get_recommended_products_from_session(self.request.session)
        return queryset

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['total_products'] = Product.objects.count()
        context['liked_products'] = get_liked_products(self.request)
        context['liked_product_ids'] = list(self.get_favorites().values_list('id', flat=True))
        context['tablets'] = Category.objects.filter(name="Tablety").first()
        context['speakers'] = Category.objects.filter(name="Glosniki komputerowe").first()
        context['laptops'] = Category.objects.filter(name="Laptopy").first()
        context['pc'] = Category.objects.filter(name="Komputery stacjonarne").first()
        return context
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
        \begin{itemize}
            \item \texttt{get\_favorites(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Zwraca produkty oznaczone jako ulubione przez użytkownika. Wykorzystuje funkcję \texttt{get\_liked\_products(self.request)}.
            \end{itemize}
            \item \texttt{get\_queryset(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Dynamicznie określa produkty wyświetlane na stronie:
                \begin{itemize}
                    \item Jeśli użytkownik jest zalogowany, pobierane są produkty rekomendowane na podstawie historii zakupów lub preferencji.
                    \item Dla użytkowników niezalogowanych pobierane są produkty z rekomendacji na podstawie sesji.
                    \item Jeśli brak rekomendacji, wybierane są losowe produkty (max 10).
                \end{itemize}
            \end{itemize}
            \item \texttt{get\_context\_data(self, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Rozszerza kontekst widoku o dodatkowe informacje:
                \begin{itemize}
                    \item \texttt{total\_products}: Całkowita liczba produktów w bazie danych.
                    \item \texttt{liked\_products}: Lista ulubionych produktów użytkownika.
                    \item \texttt{liked\_product\_ids}: Identyfikatory ulubionych produktów w postaci listy.
                    \item Kategorie: \texttt{tablets}, \texttt{speakers}, \texttt{laptops}, \texttt{pc}.
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \item \textbf{Szablony związane z widokiem:}
        \begin{itemize}
            \item {\texttt{index.html}}
                \begin{itemize}
                    \item \textbf{Opis:} Główny szablon strony, zawierający:
                    \begin{itemize}
                        \item {\texttt{main\_banner.html}}\\
                            \textbf{Opis:} Sekcja promująca główne kategorie produktów z linkami do ich podstron.\\
                        \item {\texttt{slider\_recommended.html}}\\
                            \textbf{Opis:} Suwak prezentujący rekomendowane produkty z dynamiczną obsługą przycisków do polubień i dodania do koszyka.\\
                        \item {\texttt{slider\_favorites.html}}\\
                            \textbf{Opis:} Suwak z ulubionymi produktami użytkownika, dynamicznie generowany na podstawie zalogowania lub sesji.
                    \end{itemize}
                \end{itemize}
        \end{itemize}

    \item \textbf{Skrypty JavaScript związane z widokiem:}
        \begin{itemize}
            \item \texttt{home\_page.js}
            \begin{itemize}
                \item \textbf{Opis:} Skrypt odpowiada za obsługę dynamicznych elementów na stronie głównej, takich jak:
                \begin{itemize}
                    \item Zarządzanie przewijaniem suwaków z produktami.
                    \item Obsługa przycisków „Następny” (\texttt{nxt-btn}) i „Poprzedni” (\texttt{pre-btn}).
                    \item Dynamiczne ukrywanie/wyświetlanie przycisków w zależności od pozycji przewijania suwaka.
                \end{itemize}
            \end{itemize}
        \end{itemize}    
        \begin{lstlisting}[language=JavaScript, caption=Skrypt home\_page.js]
    const productContainers = [...document.querySelectorAll('.product-container')];
    const nxtBtn = [...document.querySelectorAll('.nxt-btn')];
    const preBtn = [...document.querySelectorAll('.pre-btn')];
    
    productContainers.forEach((item, i) => {
        const screenWidth = item.clientWidth;
        function toggleBtnVisibility() {
            if (item.scrollLeft <= 0) {
                preBtn[i].style.display = 'none';
            } else {
                preBtn[i].style.display = 'block';
            }
            if (item.scrollLeft + screenWidth >= item.scrollWidth) {
                nxtBtn[i].style.display = 'none';
            } else {
                nxtBtn[i].style.display = 'block';
            }
        }
    
        toggleBtnVisibility();
        nxtBtn[i].addEventListener('click', () => {
            item.scrollLeft += screenWidth / 1.2;
            toggleBtnVisibility();
        })
        preBtn[i].addEventListener('click', () => {
            item.scrollLeft -= screenWidth / 1.3;
            toggleBtnVisibility();
        })
        item.addEventListener('scroll', toggleBtnVisibility);
    })
        \end{lstlisting}
        \textbf{Uwagi:}
        \begin{itemize}
            \item Skrypt został zaprojektowany tak, aby obsługiwać wiele suwaków jednocześnie.
            \item Dynamiczne ukrywanie przycisków nawigacyjnych (\texttt{nxt-btn}, \texttt{pre-btn}) zwiększa przejrzystość interfejsu.
        \end{itemize}
\end{itemize}

\paragraph{\texttt{AllProductsView}}
    \begin{itemize}
        \item \textbf{Opis:} Widok prezentujący wszystkie produkty w systemie z możliwością filtrowania, sortowania oraz paginacji. Widok uwzględnia również ulubione produkty użytkownika.
        \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=Kod widoku AllProductsView]
class AllProductsView(CategoriesMixin, ListView):
    model = Product
    template_name = "all_products.html"
    context_object_name = "products"
    paginate_by = 16

    def get_favorites(self):
        return get_liked_products(self.request)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['total_products'] = Product.objects.count()
        context['liked_products'] = get_liked_products(self.request)
        context['liked_product_ids'] = list(self.get_favorites().values_list('id', flat=True))
        context['min_price'] = self.request.GET.get('min_price', '')
        context['max_price'] = self.request.GET.get('max_price', '')
        context['sort_by'] = self.request.GET.get('sort_by', 'default')
        return context

    def get_queryset(self):
        queryset = Product.objects.all()
        # Sortowanie ..
        # Filtrowanie po cenie ..
        return queryset
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
        \begin{itemize}
            \item \texttt{get\_favorites(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Zwraca listę ulubionych produktów użytkownika za pomocą funkcji \texttt{get\_liked\_products}.
            \end{itemize}
            \item \texttt{get\_context\_data(self, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Dodaje do kontekstu dodatkowe dane, takie jak:
                \begin{itemize}
                    \item \texttt{total\_products}: Całkowita liczba produktów w bazie danych.
                    \item \texttt{liked\_products}: Lista ulubionych produktów użytkownika.
                    \item \texttt{liked\_product\_ids}: Identyfikatory ulubionych produktów.
                    \item \texttt{min\_price}, \texttt{max\_price}: Parametry filtrowania po cenie.
                    \item \texttt{sort\_by}: Parametr określający sposób sortowania.
                \end{itemize}
            \end{itemize}
            \item \texttt{get\_queryset(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Tworzy zapytanie do bazy danych w oparciu o wybrane przez użytkownika filtry i sortowanie.
                \begin{itemize}
                    \item Filtrowanie: Produkty są filtrowane na podstawie minimalnej i maksymalnej ceny.
                    \item Sortowanie: Obsługiwane parametry to cena, ocena i popularność (rosnąco/malejąco).
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \item \textbf{Szablony związane z widokiem:}
        \begin{itemize}
            \item \texttt{all\_products.html}
            \begin{itemize}
                \item \textbf{Opis:} Główny szablon strony z listą wszystkich produktów, zawierający:
                \begin{itemize}
                    \item Możliwość filtrowania i sortowania produktów.
                    \item Dynamiczne przyciski „Dodaj do ulubionych” i „Dodaj do koszyka”.
                    \item Obsługę paginacji.
                \end{itemize}
            \end{itemize}
        \end{itemize}

        \begin{lstlisting}[language=HTML, caption=Szablon all\_products.html]
<!-- Fragment szablonu listy wszystkich produktow -->
<div id="productsList" class="d-flex flex-wrap" style="line-height: 1.3;">
    {% csrf_token %}
    {% for product in object_list %}
        <div class="pt-2 pb-2 px-1 product-div">
            <button class="btn like-btn"
                    id="like-btn-{{ product.id }}"
                    data-product-id="{{ product.id }}">
                {% if user.is_authenticated %}
                    {% if user in product.liked_by.all %}
                        <i class="fas fa-heart" style="color: black;"></i>
                    {% else %}
                        <i class="far fa-heart"></i>
                    {% endif %}
                {% else %}
                    {% if product.id in request.session.liked_products %}
                        <i class="fas fa-heart" style="color: black;"></i>
                    {% else %}
                        <i class="far fa-heart"></i>
                    {% endif %}
                {% endif %}
            </button>
            <form method="post" action="{% url 'add_to_cart' product.id %}" class="d-inline">
                {% csrf_token %}
                <button type="submit" class="btn cart-btn" id="cart-btn-{{ product.id }}"
                        data-product-id="{{ product.id }}">
                    <i class="fas fa-shopping-cart"></i>
                </button>
            </form>
            <div class="mt-4">
                <a href="{% url 'product_detail' product.id %}">
                    <div class="mb-4">
                        <div class="image-container mt-2">
                            <img src="{{ product.image.url }}" class="card-img-top"
                                    alt="{{ product.name }}"
                                    loading="lazy">
                        </div>
                        <div class="card-body p-1 ps-2">
                            <p class="card-title">{{ product.brand }}</p>
                            <p class="card-text mb-2">{{ product.name }}</p>
                            <p class="card-text">{{ product.price }} zl</p>
                        </div>
                    </div>
                </a>
            </div>
        </div>
    {% endfor %}
</div>
            \end{lstlisting}
\end{itemize}


\paragraph{\texttt{ProductDetailView}}
    \begin{itemize}
        \item \textbf{Opis:} Widok szczegolow produktu, prezentujacy wszystkie informacje o produkcie, zdjecia, specyfikacje oraz opinie uzytkownikow.
        \item \textbf{Kod widoku:}
        \begin{lstlisting}[language=Python, caption=ProductDetailView]
class ProductDetailView(CategoriesMixin, DetailView):
    model = Product
    template_name = 'product_detail.html'
    context_object_name = 'product'

    def get(self, request, *args, **kwargs):
        response = super().get(request, *args, **kwargs)
        product = self.get_object()
        one_hour_ago = timezone.now() - timedelta(hours=1)

        if request.user.is_authenticated:
            if not UserProductVisibility.objects.filter(
                user=request.user,
                product=product,
                view_date__gte=one_hour_ago
            ).exists():
                UserProductVisibility.objects.create(
                    user=request.user, 
                    product=product, 
                    view_date=timezone.now()
                )
        else:
            if 'product_visibility' not in request.session:
                request.session['product_visibility'] = []

            session_entries = request.session['product_visibility']
            if not any(
                entry['product'] == product.id 
                and datetime.fromisoformat(entry['view_date']) >= one_hour_ago
                for entry in session_entries
            ):
                session_entries.append({
                    'product': product.id,
                    'view_date': timezone.now().isoformat()
                })
            request.session.modified = True

        return response

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        product = self.object
        context['ratings'] = product.ratings.all().order_by('-created_at')
        context['ratings_count'] = product.ratings.count()
        return context
        \end{lstlisting}

    \item \textbf{Wyjasnienie funkcji:}
        \begin{itemize}
            \item \texttt{get(self, request, *args, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Ta metoda jest odpowiedzialna za rejestrowanie widocznosci produktu. Jezeli uzytkownik jest zalogowany,
                tworzy wpis w bazie danych \texttt{UserProductVisibility}, aby odnotowac, ze produkt zostal ogladany. Jezeli uzytkownik jest anonimowy, zapisuje informacje w sesji.
            \end{itemize}
            \item \texttt{get\_context\_data(self, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Dodaje dodatkowe dane do kontekstu szablonu. W szczegolnosci:
                \begin{itemize}
                    \item \texttt{ratings}: lista ocen produktu, posortowana malejaco wedlug daty utworzenia.
                    \item \texttt{ratings\_count}: liczba ocen produktu.
                \end{itemize}
            \end{itemize}
        \end{itemize}
    
    \item \textbf{Szablony związane z widokiem:}
        \begin{itemize}
            \item \texttt{product\_detail.html}
                \begin{itemize}
                    \item \textbf{Opis:} Szablon szczegółów produktu, zawierający elementy takie jak:
                    \begin{itemize}
                        \item Galeria zdjęć produktu z obsługą karuzeli.
                        \item Szczegóły produktu (nazwa, marka, cena, średnia ocena, ulubione).
                        \item Specyfikacja techniczna z pola \texttt{product\_details}.
                        \item Opinie użytkowników oraz przycisk do edycji opinii.
                    \end{itemize}
                \end{itemize}
        \end{itemize}
        \begin{lstlisting}[language=HTML, caption=Szablon product\_detail.html]
    <!-- Fragment szablonu szczegolow produktu -->
    <div id="product-detail">
        <div id="productCarousel" class="carousel slide">
            {% for image in product.product_images_links %}
            <div class="carousel-item {% if forloop.first %}active{% endif %}">
                <img src="{{ image }}" class="d-block product-image">
            </div>
            {% endfor %}
        </div>
        <div>
            <h2>{{ product.name }}</h2>
            <p>{{ product.description }}</p>
            <span>{{ product.price }} zl</span>
        </div>
    </div>
        \end{lstlisting}


    \item \textbf{Skrypt JavaScript związany z widokiem:}
        \begin{itemize}
            \item \texttt{product\_detail.js}
            \begin{itemize}
                \item \textbf{Opis:} Skrypt odpowiada za obsługę dynamicznych elementów na stronie szczegółów produktu, takich jak:
                \begin{itemize}
                    \item Zarządzanie karuzelą zdjęć.
                    \item Obsługa przycisku „Dodaj do ulubionych”.
                    \item Dynamiczna edycja opinii użytkownika.
                \end{itemize}
            \end{itemize}
        \end{itemize}

        \begin{lstlisting}[language=JavaScript, caption=Skrypt product\_detail.js]
    // Obsluga karuzeli zdjec
    function initializeCarousel() {
        const carousel = document.getElementById('productCarousel');
    }

    // Obsluga dodawania do ulubionych
    function handleLikeButton(productId) {
        document.getElementById(`like-btn-${productId}`).addEventListener('click', () => {
        });
    }

    // Obsluga edycji opinii
    function setupEditReviewModal() {
        const editButtons = document.querySelectorAll('.edit-rating-btn');
        editButtons.forEach(button => {
            button.addEventListener('click', () => {
            });
        });
    }

    // Inicjalizacja
    document.addEventListener('DOMContentLoaded', () => {
        initializeCarousel();
        setupEditReviewModal();
    });
        \end{lstlisting}

        \textbf{Uwagi:}
            \begin{itemize}
                \item Skrypt został zaprojektowany w modularny sposób, aby obsługiwać różne funkcje na stronie szczegółów produktu.
                \item Dynamiczna obsługa przycisku „Dodaj do ulubionych” pozwala na integrację z backendem za pomocą AJAX.
                \item Funkcja obsługi karuzeli ułatwia prezentację zdjęć produktu w atrakcyjny wizualnie sposób.
            \end{itemize}
\end{itemize}

\paragraph{\texttt{ProductSearchView}}
\begin{itemize}
    \item \textbf{Opis:} Widok wyszukiwania produktów, umożliwiający filtrowanie, sortowanie i paginację wyników na podstawie wprowadzonych kryteriów. Wspiera wyszukiwanie po nazwie, marce, opisie oraz szczegółach technicznych.
    \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=ProductSearchView]
class ProductSearchView(CategoriesMixin, ListView):
    model = Product
    template_name = 'search.html'
    context_object_name = 'object_list'
    paginate_by = 16

    def get_favorites(self):
        return get_liked_products(self.request)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['total_products'] = self.get_queryset().count()
        context['liked_products'] = get_liked_products(self.request)
        context['liked_product_ids'] = list(self.get_favorites().values_list('id', flat=True))
        context['min_price'] = self.request.GET.get('min_price', '')
        context['max_price'] = self.request.GET.get('max_price', '')
        context['sort_by'] = self.request.GET.get('sort_by', 'default')
        context['search_value'] = self.request.GET.get('search_value', '')
        return context

    def get_queryset(self):
        query = self.request.GET.get('search_value')
        queryset = Product.objects.all()

        if query and len(query) >= 2:
            queryset = queryset.filter(
                Q(name__icontains=query) |
                Q(brand__icontains=query) |
                Q(description__icontains=query) |
                Q(product_details__icontains=query)
            ).distinct()
        # Sortowanie..
        # Filtrowanie po cenie..
        return queryset
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
        \begin{itemize}
            \item \texttt{get\_favorites(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Zwraca listę ulubionych produktów użytkownika, pobraną za pomocą\\ \texttt{get\_liked\_products}.
            \end{itemize}
            \item \texttt{get\_context\_data(self, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Dodaje do kontekstu dodatkowe informacje, takie jak:
                \begin{itemize}
                    \item Całkowita liczba produktów w wynikach wyszukiwania.
                    \item Lista ulubionych produktów użytkownika.
                    \item Identyfikatory ulubionych produktów.
                    \item Parametry filtrowania (\texttt{min\_price}, \texttt{max\_price}).
                    \item Aktualna wartość wyszukiwania (\texttt{search\_value}).
                \end{itemize}
            \end{itemize}
            \item \texttt{get\_queryset(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Generuje dynamiczny \texttt{QuerySet} produktów na podstawie:
                \begin{itemize}
                    \item Zapytania wyszukiwania (\texttt{search\_value}).
                    \item Parametrów sortowania (\texttt{price\_asc}, \texttt{rating\_desc}, itd.).
                    \item Filtrów cenowych (\texttt{min\_price}, \texttt{max\_price}).
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \item \textbf{Szablony związane z widokiem:}
        \begin{itemize}
            \item \texttt{search.html}
                \begin{itemize}
                    \item \textbf{Opis:} Szablon wyszukiwania produktów, zawierający elementy takie jak:
                    \begin{itemize}
                        \item Pasek wyszukiwania pozwalający na filtrowanie wyników.
                        \item Lista wyników wyszukiwania z dynamicznymi przyciskami „Dodaj do ulubionych” i „Dodaj do koszyka”.
                        \item Obsługa filtrowania, sortowania i paginacji.
                    \end{itemize}
                \end{itemize}
        \end{itemize}

    \item \textbf{Pasek wyszukiwania:}
        \begin{lstlisting}[language=HTML, caption=Pasek wyszukiwania]
<!-- Pasek wyszukiwania -->
<form role="search" method="get" action="{% url 'search' %}" class="searchBar">
    <div class="input-group">
        <input class="form-control search-input" type="search" value="{{ request.GET.search_value }}" name="search_value"
               placeholder="&#xF002;  Szukaj"
               aria-label="Search"/>
    </div>
</form>
        \end{lstlisting}
\end{itemize}

\paragraph{\texttt{FavoritesListView}}
\begin{itemize}
    \item \textbf{Opis:} Widok obsługujący listę ulubionych produktów użytkownika. Umożliwia wyświetlenie produktów oznaczonych jako ulubione, 
    z obsługą paginacji i dynamicznymi przyciskami do interakcji.
    \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=FavoritesListView]
class FavoritesListView(CategoriesMixin, ListView):
    model = Product
    template_name = "favorites.html"
    context_object_name = "liked_products"
    paginate_by = 16

    def get_queryset(self):
        return get_liked_products(self.request)

    def get_favorites(self):
        return get_liked_products(self.request)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['total_products'] = Product.objects.count()
        context['liked_products'] = get_liked_products(self.request)
        context['liked_product_ids'] = list(self.get_favorites().values_list('id', flat=True))
        context['total_liked_products'] = self.get_queryset().count()
        return context
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
        \begin{itemize}
            \item \texttt{get\_queryset(self)}:
            \begin{itemize}
                \item \textbf{Opis:} Zwraca listę produktów oznaczonych jako ulubione przez użytkownika. Używa funkcji \texttt{get\_liked\_products}, aby pobrać dane na podstawie zalogowanego użytkownika lub sesji.
            \end{itemize}
            \item \texttt{get\_context\_data(self, **kwargs)}:
            \begin{itemize}
                \item \textbf{Opis:} Dodaje do kontekstu dodatkowe informacje, takie jak:
                \begin{itemize}
                    \item \texttt{total\_products}: Całkowita liczba produktów w bazie danych.
                    \item \texttt{liked\_products}: Lista ulubionych produktów użytkownika.
                    \item \texttt{liked\_product\_ids}: Identyfikatory ulubionych produktów.
                    \item \texttt{total\_liked\_products}: Liczba produktów na liście ulubionych.
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \item \textbf{Szablony związane z widokiem:}
        \begin{itemize}
            \item \texttt{favorites.html}
                \begin{itemize}
                    \item \textbf{Opis:} Szablon wyświetlający listę ulubionych produktów użytkownika, zawierający:
                    \begin{itemize}
                        \item Listę ulubionych produktów z dynamicznymi przyciskami „Dodaj do koszyka” i „Usuń z ulubionych”.
                        \item Obsługę paginacji.
                        \item Informację o pustej liście ulubionych, jeśli użytkownik nie oznaczył żadnych produktów.
                    \end{itemize}
                \end{itemize}
        \end{itemize}

    \item \textbf{Fragment szablonu:}
        \begin{lstlisting}[language=HTML, caption=Fragment szablonu favorites.html]
<div class="d-flex flex-wrap" id="productsList" style="line-height: 1.3;">
    {% csrf_token %}
    {% for product in liked_products %}
        <div class="pt-2 pb-2 px-1 product-div">
            <button class="btn like-btn" id="like-btn-{{ product.id }}"
                    data-product-id="{{ product.id }}">
                {% if user.is_authenticated %}
                    {% if user in product.liked_by.all %}
                        <i class="fas fa-heart" style="color: black;"></i>
                    {% else %}
                        <i class="far fa-heart"></i>
                    {% endif %}
                {% else %}
                    {% if product.id in request.session.liked_products %}
                        <i class="fas fa-heart" style="color: black;"></i>
                    {% else %}
                        <i class="far fa-heart"></i>
                    {% endif %}
                {% endif %}
            </button>
            <form method="post" action="{% url 'add_to_cart' product.id %}" class="d-inline">
                {% csrf_token %}
                <button type="submit" class="btn cart-btn" id="cart-btn-{{ product.id }}"
                        data-product-id="{{ product.id }}">
                    <i class="fas fa-shopping-cart"></i>
                </button>
            </form>
            <div class="mt-4">
                <a href="{% url 'product_detail' product.id %}">
                    <div class="mb-4">
                        <div class="image-container mt-2">
                            <img src="{{ product.image.url }}" class="card-img-top"
                                 alt="{{ product.name }}"
                                 loading="lazy">
                        </div>
                        <div class="card-body p-1 ps-2">
                            <p class="card-title">{{ product.brand }}</p>
                            <p class="card-text mb-2">{{ product.name }}</p>
                            <p class="card-text">{{ product.price }} zl</p>
                        </div>
                    </div>
                </a>
            </div>
        </div>
    {% endfor %}
</div>
        \end{lstlisting}
\end{itemize}

\paragraph{\texttt{CategoryProductsView}}
\begin{itemize}
    \item \textbf{Link do opisu: }\hyperref[CategoryProductsView]{CategoryProductsView}
\end{itemize}




% 
% Model Category 
% 
\subsection{Model \texttt{Category}}
\paragraph{Opis:}  
Model \texttt{Category} przechowuje informacje o kategoriach produktów w sklepie internetowym. Umożliwia organizację produktów w strukturze hierarchicznej, dzięki relacji między nadrzędnymi a podrzędnymi kategoriami.

\subsubsection{Pola modelu}
\begin{itemize}
    \item \texttt{name}: \texttt{CharField} – nazwa kategorii (max 100 znaków).
    \item \texttt{description}: \texttt{TextField} – szczegółowy opis kategorii.
    \item \texttt{parent}: \texttt{ManyToManyField} – relacja do kategorii nadrzędnych, umożliwiająca tworzenie\\ hierarchii. 
    \begin{itemize}
        \item \texttt{blank = True} – pole jest opcjonalne.
        \item \texttt{symmetrical = False} – relacja jest niesymetryczna (rozróżnia nadrzędne i podrzędne kategorie).
        \item \texttt{related\_name = 'subcategories'} – alias do dostępu do podrzędnych kategorii.
    \end{itemize}
\end{itemize}

\paragraph{Metadane}
\begin{itemize}
    \item \texttt{verbose\_name}: \texttt{"Category"} – nazwa wyświetlana w panelu administracyjnym.
    \item \texttt{verbose\_name\_plural}: \texttt{"Categories"} – liczba mnoga dla panelu administracyjnego.
\end{itemize}


\subsubsection{Widoki modelu}
\paragraph{\texttt{CategoriesMixin}}
\begin{itemize}
    \item \textbf{Opis:} Mixin, który dodaje do kontekstu widoku listę kategorii nadrzędnych oraz podrzędnych, w zależności od wybranej kategorii. Dzięki temu umożliwia dynamiczne generowanie hierarchii kategorii produktów.

    \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=CategoriesMixin]
class CategoriesMixin(ContextMixin):
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Pobranie kategorii nadrzednych
        context['categories'] = Category.objects.filter(parent__isnull=True)

        # Sprawdzenie, czy wybrano kategorie
        selected_category_id = self.request.GET.get('category')
        if selected_category_id:
            try:
                selected_category = Category.objects.get(id=selected_category_id)
                # Dodanie podrzednych kategorii do kontekstu
                context['subcategories'] = selected_category.subcategories.all()
                context['selected_category'] = selected_category
            except Category.DoesNotExist:
                context['subcategories'] = None
                context['selected_category'] = None
        else:
            context['subcategories'] = None
            context['selected_category'] = None
        return context
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
    \begin{itemize}
        \item \texttt{get\_context\_data(self, **kwargs)}:
        \begin{itemize}
            \item \textbf{Opis:} Rozszerza kontekst widoku o:
            \begin{itemize}
                \item \texttt{categories}: Lista kategorii nadrzędnych, pobrana za pomocą filtru\\ \texttt{parent\_\_isnull = True}.
                \item \texttt{subcategories}: Lista kategorii podrzędnych, jeśli wybrano kategorię nadrzędną.
                \item \texttt{selected\_category}: Obiekt wybranej kategorii, jeśli istnieje.
            \end{itemize}
            \item Jeśli użytkownik wybierze kategorię za pomocą parametru \texttt{category}, dodawane są:
            \begin{itemize}
                \item Podrzędne kategorie jako \texttt{subcategories}.
                \item Wybrana kategoria jako \texttt{selected\_category}.
            \end{itemize}
            \item W przypadku błędu (np. kategoria nie istnieje), odpowiednie pola kontekstu są ustawiane na \texttt{None}.
        \end{itemize}
    \end{itemize}
\end{itemize}



\label{CategoryProductsView}
\paragraph{\texttt{CategoryProductsView}}
\begin{itemize}
    \item \textbf{Opis:} Widok listy produktów przypisanych do wybranej kategorii oraz jej podrzędnych. Umożliwia filtrowanie, sortowanie i paginację, a także rejestrowanie widoczności kategorii dla użytkowników.
    
    \item \textbf{Kod widoku:}
    \begin{lstlisting}[language=Python, caption=Kod widoku CategoryProductsView]
class CategoryProductsView(ListView, CategoriesMixin):
    model = Product
    template_name = 'category_products.html'
    context_object_name = 'products'
    paginate_by = 16

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category = get_object_or_404(Category, id=self.kwargs['category_id'])
        context['total_products'] = self.get_queryset().count()
        context['liked_products'] = get_liked_products(self.request)
        context['liked_product_ids'] = list(self.get_favorites().values_list('id', flat=True))
        context['min_price'] = self.request.GET.get('min_price', '')
        context['max_price'] = self.request.GET.get('max_price', '')
        context['sort_by'] = self.request.GET.get('sort_by', 'default')
        context['category'] = category
        return context

    def get_queryset(self):
        category = get_object_or_404(Category, id=self.kwargs['category_id'])
        all_categories = [category] + list(category.subcategories.all())
        for subcategory in category.subcategories.all():
            all_categories += list(subcategory.subcategories.all())
            queryset = (Product.objects.filter(categories__in=all_categories).
                        distinct())

        # Sortowanie..

        # Filtrowanie po cenie
        min_price = self.request.GET.get('min_price')
        max_price = self.request.GET.get('max_price')
        if min_price:
            queryset = queryset.filter(price__gte=min_price)
        if max_price:
            queryset = queryset.filter(price__lte=max_price)

        one_hour_ago = timezone.now() - timedelta(hours=1)

        if not max_price and not min_price and not sort_by:
            if self.request.user.is_authenticated:
                # Sprawdzenie, czy istnieje juz wpis dla danej kategorii i uzytkownika w ciagu ostatniej godziny
                if not UserCategoryVisibility.objects.filter(
                        user=self.request.user, 
                        category=category,
                        view_date__gte=one_hour_ago).exists():
                    UserCategoryVisibility.objects.create(
                        user=self.request.user, 
                        category=category,
                        view_date=timezone.now())
            else:
                if 'category_visibility' not in self.request.session:
                    self.request.session['category_visibility'] = []

                # Sprawdzenie, czy istnieje juz wpis w sesji dla danej kategorii w ciagu ostatniej godziny
                session_entries = self.request.session['category_visibility']
                if not any(
                        entry['category'] == category.id and datetime.fromisoformat(entry['view_date']) >= one_hour_ago
                        for entry in session_entries):
                    session_entries.append({
                        'category': category.id,
                        'view_date': timezone.now().isoformat()
                    })

                self.request.session.modified = True
        return queryset
    \end{lstlisting}

    \item \textbf{Wyjaśnienie funkcji:}
    \begin{itemize}
        \item \texttt{get\_context\_data(self, **kwargs)}:
        \begin{itemize}
            \item \textbf{Opis:} Rozszerza kontekst widoku o dodatkowe dane:
            \begin{itemize}
                \item \texttt{total\_products} – całkowita liczba produktów w wybranej kategorii i jej\\ podrzędnych.
                \item \texttt{liked\_products} – lista ulubionych produktów użytkownika.
                \item \texttt{liked\_product\_ids} – identyfikatory ulubionych produktów.
                \item \texttt{min\_price}, \texttt{max\_price}, \texttt{sort\_by} – parametry filtrowania i sortowania.
                \item \texttt{category} – obiekt wybranej kategorii.
            \end{itemize}
        \end{itemize}
        \item \texttt{get\_queryset(self)}:
        \begin{itemize}
            \item \textbf{Opis:} Pobiera listę produktów przypisanych do wybranej kategorii i jej podrzędnych.
            \item \textbf{Funkcjonalności:}
            \begin{itemize}
                \item Obsługuje sortowanie (np. po cenie, popularności, ocenie).
                \item Filtruje produkty na podstawie minimalnej i maksymalnej ceny.
                \item Rejestruje widoczność kategorii w bazie danych lub w sesji użytkownika.
            \end{itemize}
        \end{itemize}
    \end{itemize}

    \item \textbf{Szablony związane z widokiem:}
    \begin{itemize}
        \item \texttt{category\_products.html}:
        \begin{itemize}
            \item \textbf{Opis:} Szablon wyświetlający listę produktów dla wybranej kategorii, zawierający:
            \begin{itemize}
                \item Pasek filtrowania i sortowania produktów.
                \item Dynamiczną listę produktów z przyciskami „Dodaj do ulubionych” i „Dodaj do koszyka”.
                \item Obsługę paginacji.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}


\subsubsection{Szablony związane z modelem}
\paragraph{\texttt{header\_categories.html}}
\begin{itemize}
    \item \textbf{Opis:}  
    Szablon odpowiedzialny za wyświetlanie menu kategorii w nagłówku strony. Umożliwia użytkownikowi dostęp do kategorii nadrzędnych oraz ich podrzędnych poprzez dynamiczne rozwijanie list.
    \item \textbf{Funkcjonalności:}
    \begin{itemize}
        \item Wyświetlanie kategorii nadrzędnych jako głównych elementów menu.
        \item Dynamiczne generowanie listy podrzędnych kategorii dla każdej kategorii nadrzędnej.
        \item Przekierowanie do widoku produktów dla wybranej kategorii.
    \end{itemize}
    \item \textbf{Fragment kodu:}
    \begin{lstlisting}[language=HTML, caption=Szablon header\_categories.html]
<table class="navbar-nav">
    <tr class="ps-3">
        <th class="nav-item" id="categories-toggle" style="cursor: pointer" aria-expanded="false" title="Categories">
            <a class="nav-link mx-2"><i class="fa-solid fa-list me-2"></i>Kategorie</a>
        </th>
    </tr>
</table>
<div class="flex-wrap col-3 ps-0" id="header_categories">
    <div class="mt-2 px-0">
        <aside>
            {% for category in categories %}
                <div class="category-item" data-index="{{ forloop.counter0 }}">
                    <li class="list-unstyled my-2 mx-4">
                        <a class="category-item-txt" href="{% url 'category_products' category.id %}">{{ category.name }}</a>
                    </li>
                    {% if category.subcategories.exists %}
                        <div class="subcategory-list">
                            {% for subcategory in category.subcategories.all %}
                                <li class="list-unstyled my-2 mx-4">
                                    <a class="subcategory-item-txt" href="{% url 'category_products' subcategory.id %}">
                                        {{ subcategory.name }}
                                    </a>
                                </li>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            {% endfor %}
        </aside>
    </div>
</div>
    \end{lstlisting}
\end{itemize}

\paragraph{\texttt{left\_categories.html}}
\begin{itemize}
    \item \textbf{Opis:}  
    Szablon wyświetlający boczne menu kategorii. Umożliwia użytkownikom nawigację po hierarchii kategorii z obsługą oznaczania aktywnej kategorii.
    \item \textbf{Funkcjonalności:}
    \begin{itemize}
        \item Dynamiczne generowanie listy kategorii nadrzędnych i podrzędnych.
        \item Oznaczanie wybranej kategorii jako aktywnej.
        \item Obsługa głębszych poziomów hierarchii kategorii, takich jak subkategorie i pod-subkategorie.
        \item Dodanie formularzy do filtrowania produktów według ceny.
    \end{itemize}
    \item \textbf{Fragment kodu:}
    \begin{lstlisting}[language=HTML, caption=Fragment szablonu left\_categories.html]
<div class="d-none col-md-3" id="left-categories">
    <div class="mt-2 px-1">
        <aside>
            <ul>
                {% for main_category in categories %}
                    <li class="list-unstyled">
                        {% if main_category.id == category.id %}
                            <a href="{% url 'category_products' main_category.id %}" class="active">
                                {{ main_category.name }}
                            </a>
                        {% else %}
                            <a href="{% url 'category_products' main_category.id %}">
                                {{ main_category.name }}
                            </a>
                        {% endif %}
                    </li>
                    {% if main_category.subcategories.exists %}
                        <ul class="subcategories">
                        {% for subcategory in main_category.subcategories.all %}
                            <li class="list-unstyled">
                                <a href="{% url 'category_products' subcategory.id %}" class="fw-bold">
                                    {{ subcategory.name }}
                                </a>
                            </li>
                        {% endfor %}
                        </ul>
                    {% endif %}
                {% endfor %}
            </ul>
            #Filter Section..
        </aside>
    </div>
</div>
    \end{lstlisting}
\end{itemize}

% 
%  Model Cart | CartItem
% 

\subsection{Model \texttt{Cart} i \texttt{CartItem}}

\textbf{Opis:}  
Model \texttt{Cart} reprezentuje koszyk użytkownika, który przechowuje produkty dodane do zakupu. Model \texttt{CartItem} przechowuje szczegóły każdego elementu w koszyku, takie jak produkt, ilość i cena.

\textbf{Pola w modelu \texttt{Cart}:}
\begin{itemize}
    \item \texttt{user}: \texttt{ForeignKey} – odniesienie do użytkownika, do którego należy koszyk. Pole opcjonalne dla anonimowych użytkowników.
    \item \texttt{created\_at}: \texttt{DateTimeField} – data i czas utworzenia koszyka.
    \item \texttt{updated\_at}: \texttt{DateTimeField} – data i czas ostatniej aktualizacji koszyka.
\end{itemize}

\textbf{Pola w modelu \texttt{CartItem}:}
\begin{itemize}
    \item \texttt{cart}: \texttt{ForeignKey} – odniesienie do koszyka, w którym znajduje się dany produkt.
    \item \texttt{product}: \texttt{ForeignKey} – odniesienie do modelu \texttt{Product}.
    \item \texttt{quantity}: \texttt{PositiveIntegerField} – liczba sztuk danego produktu w koszyku (domyślnie 1).
    \item \texttt{added\_at}: \texttt{DateTimeField} – data i czas dodania produktu do koszyka.
\end{itemize}

\textbf{Metody:}
\begin{itemize}
    \item \texttt{Cart.get\_total\_price()} – Zwraca łączną wartość koszyka na podstawie cen produktów i ich ilości.
    \item \texttt{CartItem.get\_total\_price()} – Oblicza cenę za dany produkt w koszyku na podstawie jego ilości.
\end{itemize}


\subsubsection*{Widoki powiązane z koszykiem}


\paragraph{\texttt{CartDetailView}}
\begin{itemize}
    \item \textbf{Opis:} Widok szczegółowy koszyka, wyświetlający produkty, ich ilości oraz całkowitą wartość koszyka.
    \item \textbf{Kod widoku:}
\begin{lstlisting}[language=Python, caption=Kod widoku CartDetailView]
class CartDetailView(CategoriesMixin, ListView):
    template_name = 'cart_order/cart.html'
    context_object_name = 'cart_items'

    def get_queryset(self):
        # Pobieranie koszyka zalogowanego uzytkownika lub anonimowego
        if self.request.user.is_authenticated:
            cart, created = Cart.objects.get_or_create(user=self.request.user)
        else:
            cart_id = self.request.session.get('cart_id')
            cart = Cart.objects.filter(id=cart_id, user=None).first() if cart_id else None

        return CartItem.objects.filter(cart=cart) if cart else CartItem.objects.none()

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        cart_items = context['cart_items']
        total_price = sum(item.product.price * item.quantity for item in cart_items)
        context.update({
            'total_quantity': sum(item.quantity for item in cart_items),
            'total_amount': total_price,
        })
        return context
\end{lstlisting}

    \item \textbf{Wyjaśnienie:}
    \begin{itemize}
        \item \texttt{get\_queryset()} – Pobiera koszyk użytkownika lub anonimowego (na podstawie sesji) i zwraca wszystkie elementy koszyka.
        \item \texttt{get\_context\_data()} – Oblicza całkowitą ilość i wartość produktów w koszyku.
    \end{itemize}
\end{itemize}

\paragraph{\texttt{AddToCartView}}
\begin{itemize}
    \item \textbf{Opis:} Widok umożliwiający dodanie produktu do koszyka.
    \item \textbf{Kod widoku:}
\begin{lstlisting}[language=Python, caption=Kod widoku AddToCartView]
class AddToCartView(CategoriesMixin, View):
    def post(self, request, product_id):
        product = get_object_or_404(Product, id=product_id)
        quantity = int(request.POST.get('quantity', 1))

        if request.user.is_authenticated:
            cart, created = Cart.objects.get_or_create(user=request.user)
        else:
            cart_id = request.session.get('cart_id')
            cart, created = Cart.objects.get_or_create(id=cart_id, user=None) if cart_id else Cart.objects.create(user=None)
            request.session['cart_id'] = cart.id

        cart_item, created = CartItem.objects.get_or_create(cart=cart, product=product)
        cart_item.quantity += quantity if not created else quantity
        cart_item.save()

        return JsonResponse({'success': True, 'product_id': product_id, 'quantity': cart_item.quantity})
\end{lstlisting}

    \item \textbf{Wyjaśnienie:}
    \begin{itemize}
        \item Pobiera produkt na podstawie \texttt{product\_id}.
        \item Dodaje produkt do koszyka użytkownika (lub anonimowego).
        \item Zwiększa ilość produktu, jeśli już istnieje w koszyku.
    \end{itemize}
\end{itemize}

\paragraph{\texttt{RemoveFromCartView}}
\begin{itemize}
    \item \textbf{Opis:} Widok usuwający produkt z koszyka.
    \item \textbf{Kod widoku:}
\begin{lstlisting}[language=Python, caption=Kod widoku RemoveFromCartView]
class RemoveFromCartView(CategoriesMixin, View):
    def post(self, request, product_id):
        product = get_object_or_404(Product, id=product_id)
        cart = Cart.objects.filter(user=request.user).first() if request.user.is_authenticated else Cart.objects.filter(id=request.session.get('cart_id')).first()
        if not cart:
            return JsonResponse({'success': False, 'message': 'Cart not found'})

        cart_item = get_object_or_404(CartItem, cart=cart, product=product)
        cart_item.delete()

        return JsonResponse({'success': True, 'product_id': product_id})
\end{lstlisting}

    \item \textbf{Wyjaśnienie:}
    \begin{itemize}
        \item Usuwa produkt z koszyka użytkownika lub anonimowego.
        \item Zwraca odpowiedź JSON z wynikiem operacji.
    \end{itemize}
\end{itemize}

\paragraph{\texttt{UpdateCartItemView}}
\begin{itemize}
    \item \textbf{Opis:} Widok aktualizujący ilość produktu w koszyku.
    \item \textbf{Kod widoku:}
\begin{lstlisting}[language=Python, caption=Kod widoku UpdateCartItemView]
class UpdateCartItemView(CategoriesMixin, View):
    def post(self, request, product_id):
        action = request.POST.get('action')
        quantity = request.POST.get('quantity')
        product = get_object_or_404(Product, id=product_id)
        cart = Cart.objects.filter(user=request.user).first() if request.user.is_authenticated else Cart.objects.filter(id=request.session.get('cart_id')).first()

        cart_item = get_object_or_404(CartItem, cart=cart, product=product)
        if quantity:
            cart_item.quantity = max(1, int(quantity))
        elif action == 'increase':
            cart_item.quantity += 1
        elif action == 'decrease' and cart_item.quantity > 1:
            cart_item.quantity -= 1
        cart_item.save()

        return JsonResponse({'success': True, 'product_id': product_id, 'quantity': cart_item.quantity})
\end{lstlisting}

    \item \textbf{Wyjaśnienie:}
    \begin{itemize}
        \item Aktualizuje ilość produktu na podstawie żądania.
        \item Obsługuje zarówno ręczne zmiany, jak i operacje \texttt{increase}/\texttt{decrease}.
    \end{itemize}
\end{itemize}


\subsubsection{Skrypt obsługujący koszyk}

\textbf{Opis:}  
Skrypt obsługuje operacje na koszyku, takie jak dodawanie produktów, aktualizowanie ilości oraz usuwanie.

\textbf{Funkcje w skrypcie:}
\begin{itemize}
    \item \texttt{remove-from-cart} – Usuwa produkt z koszyka.
    \item \texttt{update-cart-item} – Aktualizuje ilość produktu w koszyku (przyciski + i -).
    \item \texttt{updateTotalAmount} – Przelicza całkowitą wartość koszyka.
\end{itemize}

\subsubsection{Szablon \texttt{cart.html}}

\textbf{Opis:}  
Szablon wyświetla szczegóły koszyka użytkownika, takie jak lista produktów, ich ilości, ceny i całkowitą wartość.

\textbf{Kluczowe elementy:}
\begin{itemize}
    \item \texttt{cart\_items} – Lista produktów w koszyku.
    \item \texttt{item-quantity} – Pole do zmiany ilości produktu.
    \item \texttt{remove-from-cart} – Przycisk do usunięcia produktu.
    \item \texttt{total-amount-box} – Pole wyświetlające całkowitą wartość koszyka.
\end{itemize}



\subsubsection{Skrypt obsługujący koszyk}

\textbf{Opis:}  
Skrypt \texttt{manage\_cart.js} zarządza interakcjami użytkownika z koszykiem, takimi jak dodawanie produktów, usuwanie produktów oraz aktualizowanie ich ilości. Skrypt komunikuje się z backendem za pomocą żądań AJAX oraz dynamicznie aktualizuje dane w widoku koszyka bez przeładowywania strony.

\textbf{Endpointy związane z funkcjonalnością:}
\begin{itemize}
    \item \texttt{/add-to-cart/<int:product\_id>/} – Dodawanie produktu do koszyka.
    \item \texttt{/remove-from-cart/<int:product\_id>/} – Usuwanie produktu z koszyka.
    \item \texttt{/update-cart-item/<int:product\_id>/} – Aktualizowanie ilości produktu w koszyku.
\end{itemize}

\textbf{Funkcje w skrypcie:}

\paragraph{Usuwanie produktów z koszyka (\texttt{remove-from-cart})}
\begin{itemize}
    \item \textbf{Opis:}  
    Funkcja obsługuje usuwanie produktu z koszyka. Wysyła żądanie POST do endpointu \texttt{/remove-from-cart/<int:product\_id>/} i po pomyślnym usunięciu aktualizuje widok koszyka.
    \item \textbf{Kod:}
\begin{lstlisting}[language=JavaScript, caption=Kod funkcji remove-from-cart]
$('.remove-from-cart').click(function (event) {
    event.preventDefault();
    const productId = $(this).data('product-id');
    const card = $(this).closest('.card');

    $.ajax({
        url: '/remove-from-cart/' + productId + '/',
        type: 'POST',
        headers: { 'X-CSRFToken': csrftoken },
        success: function (response) {
            if (response.success) {
                card.remove(); // Usuwa produkt z widoku
                updateTotalAmount(); 
            }
        }
    });
});
\end{lstlisting}
    \item \textbf{Powiązane elementy w szablonie:}
    \begin{itemize}
        \item Przycisk \texttt{.remove-from-cart} w \texttt{cart.html}.
        \item Pole \texttt{total-amount-box}, które jest dynamicznie aktualizowane.
    \end{itemize}
\end{itemize}

\paragraph{Aktualizacja ilości produktów (\texttt{update-cart-item})}
\begin{itemize}
    \item \textbf{Opis:}  
    Funkcja aktualizuje ilość wybranego produktu w koszyku. Obsługuje zarówno ręczne wprowadzanie ilości, jak i przyciski zwiększania/zwiększania ilości.
    \item \textbf{Kod:}
\begin{lstlisting}[language=JavaScript, caption=Kod funkcji update-cart-item]
$('.update-cart-item').click(function (event) {
    event.preventDefault();
    const productId = $(this).data('product-id');
    const action = $(this).data('action');
    const quantityInput = $(this).siblings('.item-quantity');
    let quantity = parseInt(quantityInput.val());

    if (action === 'increase') {
        quantity += 1;
    } else if (action === 'decrease' && quantity > 1) {
        quantity -= 1;
    }

    quantityInput.val(quantity); // Aktualizuje widok
    updateTotalPrice(productId, quantity);

    $.ajax({
        url: '/update-cart-item/' + productId + '/',
        type: 'POST',
        headers: { 'X-CSRFToken': csrftoken },
        data: { action: action },
        success: function (response) {
            if (response.success) {
                updateTotalAmount(); 
            }
        }
    });
});
\end{lstlisting}
    \item \textbf{Powiązane elementy w szablonie:}
    \begin{itemize}
        \item Przycisk \texttt{.update-cart-item} w \texttt{cart.html}.
        \item Pole \texttt{item-quantity}, gdzie użytkownik może ręcznie zmieniać ilość.
    \end{itemize}
\end{itemize}

\paragraph{Aktualizacja całkowitej wartości koszyka (\texttt{updateTotalAmount})}
\begin{itemize}
    \item \textbf{Opis:}  
    Funkcja oblicza całkowitą wartość koszyka na podstawie ilości i ceny produktów. Jest wywoływana po każdej zmianie w koszyku.
    \item \textbf{Kod:}
\begin{lstlisting}[language=JavaScript, caption=Kod funkcji updateTotalAmount]
function updateTotalAmount() {
    let total = 0;

    $('.item-total-price').each(function () {
        const unitPrice = parseFloat($(this).data('unit-price'));
        const quantity = parseInt($(this).closest('.row').find('.item-quantity').val());
        total += unitPrice * quantity;
    });

    $('.total-amount-box').text(`Calkowita kwota: ${total.toFixed(2)} zl`);
}
\end{lstlisting}
    \item \textbf{Powiązane elementy w szablonie:}
    \begin{itemize}
        \item Pole \texttt{total-amount-box}, wyświetlające łączną wartość koszyka.
        \item Elementy \texttt{item-total-price}, reprezentujące ceny jednostkowe produktów.
    \end{itemize}
\end{itemize}

\paragraph{Dodawanie produktów do koszyka (\texttt{add-to-cart})}
\begin{itemize}
    \item \textbf{Opis:}  
    Funkcja dodaje wybrany produkt do koszyka, wysyłając żądanie POST do endpointu \texttt{/add-to-cart/<int:product\_id>/}.
    \item \textbf{Kod:}
\begin{lstlisting}[language=JavaScript, caption=Kod funkcji add-to-cart]
$('.add-to-cart').click(function (event) {
    event.preventDefault();
    const productId = $(this).data('product-id');
    const quantity = $(this).data('quantity') || 1;

    $.ajax({
        url: '/add-to-cart/' + productId + '/',
        type: 'POST',
        headers: { 'X-CSRFToken': csrftoken },
        data: { quantity: quantity },
        success: function (response) {
            if (response.success) {
                alert("Produkt zostal dodany do koszyka!");
            }
        }
    });
});
\end{lstlisting}
    \item \textbf{Powiązane elementy w szablonie:}
    \begin{itemize}
        \item Przycisk \texttt{.add-to-cart} w szablonach produktów.
    \end{itemize}
\end{itemize}


% 
% Model Order
% 
\subsubsection{Model \texttt{Order}}

\textbf{Opis:}  
Model \texttt{Order} reprezentuje zamówienie w systemie. Każde zamówienie jest powiązane z użytkownikiem, produktami, adresem dostawy oraz metodą płatności. Zawiera również mechanizmy zarządzania statusem zamówienia oraz integrację z konwersacjami użytkownika i administratora.

\textbf{Pola w modelu:}
\begin{itemize}
    \item \texttt{user} – \texttt{ForeignKey} powiązany z modelem \texttt{User}, oznacza właściciela zamówienia.
    \item \texttt{products} – \texttt{ManyToManyField} powiązany z modelem \texttt{Product}, lista zamówionych produktów.
    \item \texttt{status} – \texttt{CharField} określający status zamówienia (\texttt{created}, \texttt{processing}, \texttt{in\_delivery}, itd.).
    \item \texttt{previous\_status} – \texttt{CharField} przechowujący poprzedni status zamówienia, używany do śledzenia zmian.
    \item \texttt{delivery\_address} – \texttt{ForeignKey} do modelu \texttt{Address}, adres dostawy.
    \item \texttt{payment\_method} – \texttt{ForeignKey} do modelu \texttt{PaymentMethod}, wybrana metoda płatności.
    \item \texttt{total\_amount} – \texttt{DecimalField}, całkowita wartość zamówienia.
\end{itemize}

\textbf{Metody modelu:}
\begin{itemize}
    \item \texttt{\_\_str\_\_()}: Zwraca czytelną reprezentację zamówienia w formacie:
    \begin{lstlisting}[language=Python]
"Zamowienie #<id> (<username>) - <status>"
    \end{lstlisting}
\end{itemize}

\subsubsection{Widoki związane z zamówieniami}

\paragraph{\texttt{OrderCreateView}}
\begin{itemize}
    \item \textbf{Opis:} Widok odpowiedzialny za tworzenie nowego zamówienia. Proces obejmuje:
    \begin{enumerate}
        \item Pobranie koszyka użytkownika.
        \item Walidację wybranego adresu dostawy i metody płatności.
        \item Utworzenie zamówienia i przeniesienie produktów z koszyka do zamówienia.
        \item Usunięcie produktów z koszyka.
        \item Utworzenie dwóch konwersacji z administratorem:
        \begin{itemize}
            \item Status zamówienia.
            \item Ogólna komunikacja dotycząca zamówienia.
        \end{itemize}
        \item Wysłanie wiadomości e-mail z potwierdzeniem zamówienia.
        \item Przekierowanie użytkownika do szczegółów zamówienia.
    \end{enumerate}
    \item \textbf{Metoda \texttt{create\_order()}:} Główna metoda realizująca proces tworzenia zamówienia.
    \begin{lstlisting}[language=Python, caption=Kod metody create_order]
def create_order(self, request):
    user = request.user
    cart = Cart.objects.filter(user=user).first()

    if not cart or not cart.items.exists():
        messages.error(request, "Twoj koszyk jest pusty.")
        return redirect('cart_detail')

    order_session = request.session.get('order_session', {})
    delivery_address = Address.objects.filter(id=order_session.get('selected_address_id'), user=user).first()
    payment_method = PaymentMethod.objects.filter(id=order_session.get('payment_method_id'), user=user).first()

    if not delivery_address or not payment_method:
        messages.error(request, "Brakuje wymaganych informacji.")
        return redirect('cart_detail')

    order = Order.objects.create(
        user=user,
        delivery_address=delivery_address,
        payment_method=payment_method,
        total_amount=cart.get_total_price(),
    )

    for item in cart.items.all():
        order.products.add(item.product)

    cart.items.all().delete()
    return redirect('order_detail', pk=order.id)
    \end{lstlisting}

    \item \textbf{Wysyłanie potwierdzenia e-mail:}
    Po utworzeniu zamówienia, użytkownik otrzymuje wiadomość e-mail z podsumowaniem zamówienia, w tym:
    \begin{itemize}
        \item Numer zamówienia.
        \item Adres dostawy.
        \item Metodę płatności.
        \item Całkowitą kwotę.
        \item Listę produktów w zamówieniu.
    \end{itemize}
    Widok korzysta z funkcji \texttt{send\_order\_confirmation\_email}, która renderuje wiadomość e-mail na podstawie szablonu \texttt{email/order\_confirmation\_email.html}.
    \begin{lstlisting}[language=Python]
def send_order_confirmation_email(order):
    subject = f"Dziekujemy za zamowienie #{order.id} w KMG Store"
    html_message = render_to_string('email/order_confirmation_email.html', {
        'user': order.user,
        'order': order,
        'delivery_address': order.delivery_address,
        'payment_method': order.payment_method,
        'total_amount': order.total_amount,
        'products': order.products.all(),
    })
    plain_message = strip_tags(html_message)
    send_mail(
        subject,
        plain_message,
        'kmgstoreproject@gmail.com',
        [order.user.email],
        html_message=html_message,
    )
    \end{lstlisting}

\end{itemize}

\paragraph{\texttt{OrderDetailView}}
\begin{itemize}
    \item \textbf{Opis:} Widok szczegółów zamówienia, dostępny dla użytkownika (tylko jego zamówienia) i administratora (wszystkie zamówienia).
    \item \textbf{Szablon:} \texttt{order\_detail.html}
    \item \textbf{Konfiguracja kontekstu:}
    \begin{itemize}
        \item \texttt{products} – lista produktów w zamówieniu.
        \item \texttt{can\_rate} – możliwość oceniania produktów, dostępna po zakończeniu zamówienia.
    \end{itemize}
\end{itemize}

\paragraph{\texttt{OrderListView}}
\begin{itemize}
    \item \textbf{Opis:} Widok listy zamówień użytkownika, posortowany malejąco według daty utworzenia.
    \item \textbf{Szablon:} \texttt{order\_list.html}
\end{itemize}

\paragraph{\texttt{get\_order\_status}}
\begin{itemize}
    \item \textbf{Opis:} Endpoint zwracający aktualny status zamówienia w formacie JSON.
    \item \textbf{Szablon:} Brak (czysto API).
    \item \textbf{Kod:}
    \begin{lstlisting}[language=Python]
def get_order_status(request, order_id):
    if request.user.is_authenticated:
        order = get_object_or_404(Order, id=order_id, user=request.user)
        return JsonResponse({'status': order.status})
    return JsonResponse({'error': 'Unauthorized'}, status=401)
    \end{lstlisting}
\end{itemize}

\subsubsection{Signals dla zamówień}

\paragraph{\texttt{simulate\_status\_update}}
\begin{itemize}
    \item \textbf{Opis:} Symuluje aktualizację statusu zamówienia w czasie (np. przetwarzanie, dostawa, odbiór).
    \item \textbf{Kod:}
    \begin{lstlisting}[language=Python]
@receiver(post_save, sender=Order)
def simulate_status_update(sender, instance, created, **kwargs):
    if created:
        status_flow = ['processing', 'in_delivery', 'ready_for_pickup', 'completed']
        def update_status(order, statuses):
            for status in statuses:
                if order.status == 'completed':
                    break
                time.sleep(5)
                order.status = status
                order.save(update_fields=['status'])
        Thread(target=update_status, args=(instance, status_flow)).start()
    \end{lstlisting}
\end{itemize}

\paragraph{\texttt{track\_previous\_status}}
\begin{itemize}
    \item \textbf{Opis:} Śledzi poprzedni status zamówienia przed zapisaniem.
    \item \textbf{Kod:}
    \begin{lstlisting}[language=Python]
@receiver(pre_save, sender=Order)
def track_previous_status(sender, instance, **kwargs):
    if instance.pk:
        previous_order = Order.objects.filter(pk=instance.pk).first()
        if previous_order:
            instance.previous_status = previous_order.status
    \end{lstlisting}
\end{itemize}

\subsubsection{Szablony związane z zamówieniami}

\paragraph{\texttt{order\_detail.html}}
\begin{itemize}
    \item \textbf{Opis:} 
    Szablon szczegółów zamówienia, wyświetlający podstawowe informacje o zamówieniu, postęp dostawy oraz produkty wchodzące w skład zamówienia.  
    \item \textbf{Kluczowe sekcje:}
    \begin{itemize}
        \item \textbf{Nagłówek zamówienia:} 
        Wyświetla ID zamówienia, status, całkowitą kwotę, datę utworzenia, adres dostawy i metodę płatności.
        \begin{lstlisting}[language=HTML]
<p>Zamowienie: <strong>#{{ order.id }}</strong></p>
<p>Status: <strong>{{ order.get_status_display }}</strong></p>
<p>Laczna kwota: <strong>{{ order.total_amount|floatformat:2 }} zl</strong></p>
        \end{lstlisting}
        \item \textbf{Produkty w zamówieniu:} 
        Lista produktów z linkami do szczegółów produktu, ceną, marką oraz możliwością oceny (jeśli zamówienie jest zakończone).
        \begin{lstlisting}[language=HTML]
{% for product in order.products.all %}
<div class="order_detail_product_details">
    <a href="{% url 'product_detail' product.id %}">
        <strong>{{ product.name }}</strong>
    </a>
    <p>Cena: {{ product.price|floatformat:2 }} zl</p>
</div>
{% endfor %}
        \end{lstlisting}
        \item \textbf{Postęp dostawy:}
        Wykorzystuje elementy \texttt{li} do wizualizacji statusu zamówienia, zaznaczając aktualny i zakończone etapy.
        \begin{lstlisting}[language=HTML]
<li class="order_detail_step {% if order.status == 'completed' %}completed{% endif %}">
    <div class="order_detail_circle">5</div>
    <div class="order_detail_label">Zakonczone</div>
</li>
        \end{lstlisting}
    \end{itemize}
\end{itemize}

\paragraph{\texttt{order\_list.html}}
\begin{itemize}
    \item \textbf{Opis:} 
    Szablon listy zamówień użytkownika, zawierający podstawowe informacje o zamówieniach oraz przyciski do szczegółów zamówienia.
    \item \textbf{Kluczowe sekcje:}
    \begin{itemize}
        \item \textbf{Nagłówek:} Wyświetla listę zamówień użytkownika lub informację o braku zamówień.
        \item \textbf{Karty zamówień:} Zawierają ID zamówienia, datę utworzenia, kwotę oraz przycisk do szczegółów.
        \begin{lstlisting}[language=HTML]
<div class="order-card">
    <div class="order-info">
        <strong>Zamowienie #{{ order.id }}</strong>
        <p>Data utworzenia: {{ order.created_at }}</p>
        <p>Laczna kwota: {{ order.total_amount|floatformat:2 }} zl</p>
    </div>
    <div class="order-actions">
        <a href="{% url 'order_detail' order.id %}" class="btn-order-details">Szczegoly</a>
    </div>
</div>
        \end{lstlisting}
    \end{itemize}
\end{itemize}

\subsubsection{Szablon e-maila potwierdzającego zamówienie}

\paragraph{\texttt{email/order\_confirmation\_email.html}}
\begin{itemize}
    \item \textbf{Opis:} Szablon HTML wiadomości e-mail, wysyłanej do użytkownika po utworzeniu zamówienia. Zawiera szczegóły zamówienia, takie jak numer, adres dostawy, metoda płatności, kwota całkowita oraz lista produktów.
    \item \textbf{Kluczowe sekcje:}
    \begin{itemize}
        \item Nagłówek z podziękowaniem i imieniem użytkownika.
        \item Lista szczegółów zamówienia:
        \begin{lstlisting}[language=HTML]
<ul>
    <li><strong>Numer zamowienia:</strong> {{ order.id }}</li>
    <li><strong>Adres dostawy:</strong> {{ delivery_address.street }}, {{ delivery_address.city }}</li>
    <li><strong>Metoda platnosci:</strong> {{ payment_method.payment_method }}</li>
    <li><strong>Kwota calkowita:</strong> {{ total_amount }} zl</li>
</ul>
        \end{lstlisting}
        \item Informacja kontaktowa z zespołem KMG Store.
    \end{itemize}
\end{itemize}

\subsubsection{Skrypt \texttt{order\_detail.js}}
\begin{itemize}
    \item \textbf{Opis:} 
    Obsługuje dynamiczne funkcjonalności związane z zamówieniem, takie jak oceny produktów i automatyczne odświeżanie statusu zamówienia.
    \item \textbf{Funkcjonalności:}
    \begin{itemize}
        \item \textbf{Obsługa ocen produktów:}
        Wysyła formularz oceny za pomocą żądania \texttt{POST}, a następnie resetuje pola formularza po sukcesie.
        \begin{lstlisting}[language=JavaScript]
form.addEventListener('submit', function (event) {
    event.preventDefault();
    const formData = new FormData(form);
    fetch(form.action, { method: 'POST', body: formData })
        .then(response => response.json())
        .then(data => {
            if (data.error) alert(data.error);
            else alert('Dziekujemy za ocene!');
        });
});
        \end{lstlisting}
        \item \textbf{Sprawdzanie statusu zamówienia:}
        Wysyła żądanie \texttt{GET} do endpointu \texttt{/order-status/<order\_id>/}, odświeżając stronę po zmianie statusu.
        \begin{lstlisting}[language=JavaScript]
function checkOrderStatus() {
    fetch(`/order-status/${orderId}/`)
        .then(response => response.json())
        .then(data => {
            if (data.status !== currentStatus) {
                currentStatus = data.status;
                location.reload();
            }
        });
}
setInterval(checkOrderStatus, 5000);
        \end{lstlisting}
        \item \textbf{Inicjalizacja:} Sprawdza początkowy status zamówienia i zatrzymuje odświeżanie, jeśli jest zakończone.
        \begin{lstlisting}[language=JavaScript]
if (currentStatus === 'completed') {
    clearInterval(statusInterval);
}
        \end{lstlisting}
    \end{itemize}
\end{itemize}


% 
% Model Rate
% 

\subsubsection{Model \texttt{Rate}}

\textbf{Opis:}  
Model \texttt{Rate} przechowuje informacje o ocenach wystawionych przez użytkowników dla produktów. Każda ocena zawiera wartość numeryczną (1–5), opcjonalny komentarz oraz dane o użytkowniku i ocenianym produkcie.

\textbf{Kod:}
\begin{lstlisting}[language=Python]
class Rate(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='ratings')
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='ratings')
    value = models.IntegerField()  # Oceny w zakresie 1-5
    comment = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.username} - {self.product.name}: {self.value}"

    def can_edit(self, user):
        return self.user == user
\end{lstlisting}

\textbf{Atrybuty:}
\begin{itemize}
    \item \texttt{user} – relacja \texttt{ForeignKey} do modelu \texttt{User}, określa użytkownika wystawiającego ocenę.
    \item \texttt{product} – relacja \texttt{ForeignKey} do modelu \texttt{Product}, określa oceniany produkt.
    \item \texttt{value} – liczba całkowita, określa wartość oceny w skali od 1 do 5.
    \item \texttt{comment} – opcjonalny komentarz użytkownika (pole tekstowe).
    \item \texttt{created\_at} – data i czas utworzenia oceny.
\end{itemize}

\textbf{Metody:}
\begin{itemize}
    \item \texttt{\_\_str\_\_()} – zwraca czytelną reprezentację obiektu w formacie \texttt{"username - product\_name: value"}.
    \item \texttt{can\_edit(user)} – sprawdza, czy dany użytkownik ma prawo edytować ocenę.
\end{itemize}


\subsubsection{Widoki dla modelu rate}

\subsubsection{Widok \texttt{rate\_product}}

\textbf{Opis:}  
Widok \texttt{rate\_product} obsługuje żądania POST związane z wystawianiem lub edytowaniem ocen produktów. Umożliwia aktualizację średniej oceny produktu po dodaniu lub edycji oceny.

\textbf{Kod:}
\begin{lstlisting}[language=Python]
@csrf_exempt
def rate_product(request, product_id, rating_id=None):
    if request.method == "POST":
        product = get_object_or_404(Product, id=product_id)
        user = request.user
        value = int(request.POST.get('value', 0))
        comment = request.POST.get('comment', '')

        if not (1 <= value <= 5):
            return JsonResponse({'error': 'Invalid rating value'}, status=400)

        if rating_id:  # update existing rate
            rate = get_object_or_404(Rate, id=rating_id, user=user, product=product)
            rate.value = value
            rate.comment = comment
            rate.save()
            created = False
            message = 'Rating updated'
        else:  # creating new rate
            rate = Rate.objects.create(
                user=user,
                product=product,
                value=value,
                comment=comment
            )
            created = True
            message = 'Rating created'

        # update average rate based on new/changed rate
        product.update_average_rate()

        return JsonResponse({
            'message': message,
            'created': created,
            'average_rate': product.average_rate,
            'rating_count': product.ratings.count(),
            'user_rating': {
                'value': rate.value,
                'comment': rate.comment
            }
        })
    return JsonResponse({'error': 'Invalid request method'}, status=400)
\end{lstlisting}

\textbf{Funkcjonalność:}
\begin{itemize}
    \item Tworzenie nowej oceny produktu.
    \item Aktualizacja istniejącej oceny.
    \item Walidacja wartości oceny (\texttt{value}) w zakresie 1–5.
    \item Zwracanie odpowiedzi JSON z informacjami o wyniku operacji, średniej ocenie i liczbie ocen.
\end{itemize}

\textbf{Zależności:}
\begin{itemize}
    \item \texttt{product.update\_average\_rate()} – aktualizuje średnią ocenę produktu na podstawie wszystkich wystawionych ocen.
\end{itemize}

\subsubsection{Fragment HTML: Formularz Ocen Produktów}

\textbf{Opis:}  
Formularz w szablonie \texttt{order\_detail.html} umożliwia wystawienie oceny i dodanie komentarza do produktów zrealizowanego zamówienia.

\textbf{Kod:}
\begin{lstlisting}[language=HTML]
{% if can_rate %}
    <div class="order_detail_product_rate">
        <h4>Ocen ten produkt:</h4>
        <form method="POST" action="{% url 'rate_product' product.id %}" class="rating_form">
            {% csrf_token %}
            <input type="hidden" name="new_rate" value="true">
            <div class="form_group">
                <label for="rating_{{ product.id }}">Ocena (od 1 do 5):</label>
                <input type="number" id="rating_{{ product.id }}" name="value" min="1" max="5" required>
            </div>
            <div class="form_group">
                <label for="comment_{{ product.id }}">Komentarz:</label>
                <textarea id="comment_{{ product.id }}" name="comment" rows="3"></textarea>
            </div>
            <button type="submit" class="rate_submit_button">Wyslij ocene</button>
        </form>
    </div>
{% endif %}
\end{lstlisting}

\textbf{Funkcjonalność:}
\begin{itemize}
    \item Umożliwia użytkownikowi ocenę produktu (wartość 1–5).
    \item Umożliwia dodanie komentarza do oceny.
    \item Formularz jest dostępny tylko dla produktów z zamówień oznaczonych jako \texttt{completed}.
\end{itemize}




\subsubsection{Skrypt: Obsługa Formularza Ocen}

\textbf{Opis:}  
Skrypt \texttt{order\_detail.js} obsługuje wysyłanie formularza ocen produktów za pomocą AJAX.

\textbf{Kod:}
\begin{lstlisting}[language=JavaScript]
document.addEventListener('DOMContentLoaded', function () {
    const ratingForms = document.querySelectorAll('.rating_form');

    ratingForms.forEach(form => {
        form.addEventListener('submit', function (event) {
            event.preventDefault();
            const formData = new FormData(form);

            fetch(form.action, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken')
                }
            })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                    } else {
                        alert('Dziekujemy za wystawienie oceny!');
                        form.querySelector('[name="value"]').value = '';
                        form.querySelector('[name="comment"]').value = '';
                    }
                })
                .catch(error => console.error('Blad:', error));
        });
    });
});
\end{lstlisting}

\textbf{Funkcjonalność:}
\begin{itemize}
    \item Wysyłanie formularzy ocen metodą \texttt{POST}.
    \item Walidacja odpowiedzi serwera i obsługa komunikatów zwrotnych (błędy/sukces).
    \item Czyszczenie pól formularza po prawidłowym wysłaniu.
\end{itemize}


\subsection{Funkcjonalność edytowania opinii}

\subsubsection{Model \texttt{Rate}}
Model \texttt{Rate} jest już opisany w głównej dokumentacji. W kontekście edycji opinii istotna jest metoda \texttt{can\_edit(user)}, która sprawdza, czy dany użytkownik może edytować swoją opinię.

\begin{lstlisting}[language=Python, caption=Metoda \texttt{can\_edit}]
def can_edit(self, user):
    return self.user == user
\end{lstlisting}

---

\subsubsection{Widoki związane z edycją opinii}

\paragraph{Widok \texttt{rate\_product}}
Widok obsługuje tworzenie i edytowanie opinii. Jeśli \texttt{rating\_id} zostanie przekazane, istniejąca opinia jest aktualizowana; w przeciwnym razie tworzona jest nowa.

\begin{lstlisting}[language=Python, caption=Widok \texttt{rate\_product}, label=rate_product_view]
@csrf_exempt
def rate_product(request, product_id, rating_id=None):
    if request.method == "POST":
        product = get_object_or_404(Product, id=product_id)
        user = request.user
        value = int(request.POST.get('value', 0))
        comment = request.POST.get('comment', '')

        if not (1 <= value <= 5):
            return JsonResponse({'error': 'Invalid rating value'}, status=400)

        if rating_id:
            rate = get_object_or_404(Rate, id=rating_id, user=user, product=product)
            rate.value = value
            rate.comment = comment
            rate.save()
            message = 'Rating updated'
        else:
            rate = Rate.objects.create(user=user, product=product, value=value, comment=comment)
            message = 'Rating created'

        product.update_average_rate()

        return JsonResponse({
            'message': message,
            'average_rate': product.average_rate,
            'rating_count': product.ratings.count(),
            'user_rating': {'value': rate.value, 'comment': rate.comment}
        })
    return JsonResponse({'error': 'Invalid request method'}, status=400)
\end{lstlisting}

---

\paragraph{Widok \texttt{get\_ratings\_html}}
Widok generuje dynamicznie HTML dla listy opinii danego produktu.

\begin{lstlisting}[language=Python, caption=Widok \texttt{get\_ratings\_html}]
def get_ratings_html(request, product_id):
    product = get_object_or_404(Product, id=product_id)
    ratings = product.ratings.all().order_by('-created_at')
    html = render_to_string('rating_list.html', {'ratings': ratings, 'user': request.user})
    return JsonResponse({'html': html})
\end{lstlisting}

---

\subsubsection{Szablony}

\paragraph{Fragment \texttt{rating\_list.html}}
Wyświetla listę opinii z możliwością edycji, jeśli użytkownik jest właścicielem opinii.

\begin{lstlisting}[language=HTML, caption=Szablon \texttt{rating\_list.html}]
{% for rating in ratings %}
    <div class="review-card mb-3">
        <strong>{{ rating.user.username }}</strong>
        <div>
            {% for i in "12345" %}
                {% if rating.value >= forloop.counter %}
                    <i class="bi bi-star-fill text-warning"></i>
                {% else %}
                    <i class="bi bi-star text-warning"></i>
                {% endif %}
            {% endfor %}
        </div>
        <p class="review-comment">{{ rating.comment }}</p>
        <p class="text-muted">Added: {{ rating.created_at }}</p>

        {% if user.is_authenticated and rating.user == user %}
            <button class="btn btn-sm btn-outline-secondary edit-rating-btn" data-rating-id="{{ rating.id }}">
                Edit
            </button>
        {% endif %}
    </div>
{% empty %}
    <p>No reviews yet. Be the first!</p>
{% endfor %}
\end{lstlisting}

\paragraph{Fragment \texttt{product\_detail.html}}
Obsługuje formularz edycji opinii w modalu.

\begin{lstlisting}[language=HTML, caption=Fragment \texttt{product\_detail.html}]
<div id="edit-rating-modal" style="display: none;">
    <form method="post" id="edit-rating-form" action="{% url 'rate_product' product.id %}" data-product-id="{{ product.id }}">
        {% csrf_token %}
        <input type="hidden" name="rating_id" id="edit-rating-id">
        <div class="form-group">
            <label for="edit-rating-value">Rating:</label>
            <input type="number" name="value" id="edit-rating-value" class="form-control" min="1" max="5" required>
        </div>
        <div class="form-group">
            <label for="edit-rating-comment">Comment:</label>
            <textarea name="comment" id="edit-rating-comment" class="form-control"></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Save</button>
        <button type="button" class="btn btn-secondary cancel-edit-btn">Cancel</button>
    </form>
</div>
\end{lstlisting}

---

\subsubsection{Skrypt \texttt{product\_detail.js}}
Obsługuje modal edycji opinii oraz dynamiczną aktualizację treści opinii na stronie.

\begin{lstlisting}[language=JavaScript, caption=Fragment \texttt{product\_detail.js}]
document.addEventListener('DOMContentLoaded', () => {
    const editButtons = document.querySelectorAll('.edit-rating-btn');

    editButtons.forEach(button => {
        button.addEventListener('click', function () {
            const ratingId = this.dataset.ratingId;
            const ratingValue = this.closest('.review-card').querySelectorAll('.bi-star-fill').length;
            const ratingComment = this.closest('.review-card').querySelector('.review-comment').innerText;

            document.getElementById('edit-rating-id').value = ratingId;
            document.getElementById('edit-rating-value').value = ratingValue;
            document.getElementById('edit-rating-comment').value = ratingComment;

            document.getElementById('edit-rating-modal').style.display = 'block';
        });
    });

    document.querySelector('.cancel-edit-btn').addEventListener('click', () => {
        document.getElementById('edit-rating-modal').style.display = 'none';
    });
});
\end{lstlisting}

---

\subsubsection{Podsumowanie}
Funkcjonalność edycji opinii pozwala użytkownikom na aktualizowanie swoich recenzji. Widoki generują dynamicznie treść i umożliwiają edycję w modalu, co jest obsługiwane przez \texttt{JavaScript}. Wszystkie zmiany są automatycznie synchronizowane z bazą danych oraz wyświetlają się w czasie rzeczywistym na stronie.

% 
% Model Reation
% 

\subsection{Funkcjonalność reakcji na produkty}

\subsubsection{Model \texttt{Reaction}}
Model \texttt{Reaction} obsługuje reakcje użytkowników na produkty (polubienia i oznaczenia jako niepolubione). 

\begin{lstlisting}[language=Python, caption=Model \texttt{Reaction}]
class Reaction(models.Model):
    REACTION_CHOICES = [('like', 'Like'), ('dislike', 'Dislike')]
    user = models.ForeignKey('User', on_delete=models.CASCADE)
    product = models.ForeignKey('Product', on_delete=models.CASCADE)
    assigned_date = models.DateTimeField(auto_now_add=True)
    type = models.CharField(max_length=10, choices=REACTION_CHOICES)

    def __str__(self):
        return f"{self.user.first_name} - {self.product.name}: {self.type}"
\end{lstlisting}

---

\subsubsection{Widoki związane z reakcjami}

\paragraph{Widok \texttt{product\_like}}
Ten widok obsługuje polubienia oraz niepolubienia produktów, uwzględniając zarówno użytkowników zalogowanych, jak i sesje użytkowników niezalogowanych. W przypadku użytkowników zalogowanych dane są przechowywane w bazie danych, a dla niezalogowanych – w sesji.

\begin{lstlisting}[language=Python, caption=Widok \texttt{product\_like}, label=product_like_view]
def product_like(request, product_id):
    product = get_object_or_404(Product, id=product_id)

    if request.user.is_authenticated:
        if request.user in product.liked_by.all():
            product.liked_by.remove(request.user)
            liked = False
            reaction, created = Reaction.objects.get_or_create(
                user=request.user, product=product, type='dislike'
            )
            reaction.assigned_date = timezone.now()
            reaction.save()
        else:
            product.liked_by.add(request.user)
            liked = True
            reaction, created = Reaction.objects.get_or_create(
                user=request.user, product=product, type='like'
            )
            reaction.assigned_date = timezone.now()
            reaction.save()

        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'liked': liked, 'likes_count': product.liked_by.count()})

    else:
        liked_products = request.session.get('liked_products', [])
        session_reactions = request.session.get('session_reactions', [])
        existing_reaction = next((r for r in session_reactions if r['product_id'] == product.id), None)

        if product.id in liked_products:
            liked_products.remove(product.id)
            liked = False
            if existing_reaction:
                existing_reaction['type'] = 'dislike'
                existing_reaction['date'] = str(timezone.now())
            else:
                session_reactions.append({
                    'product_id': product.id,
                    'type': 'dislike',
                    'date': str(timezone.now())
                })
        else:
            liked_products.append(product.id)
            liked = True
            if existing_reaction:
                existing_reaction['type'] = 'like'
                existing_reaction['date'] = str(timezone.now())
            else:
                session_reactions.append({
                    'product_id': product.id,
                    'type': 'like',
                    'date': str(timezone.now())
                })

        request.session['liked_products'] = liked_products
        request.session['session_reactions'] = session_reactions

        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'liked': liked, 'likes_count': len(liked_products)})

    return redirect('index')
\end{lstlisting}

---

\subsubsection{Szablony}

\paragraph{\texttt{product\_detail.html} oraz \texttt{order\_detail.html}}
Przyciski reakcji są identyczne w obu szablonach. 
\label{likeBtn}

\begin{lstlisting}[language=HTML, caption=Przycisk reakcji]
<button class="btn like-btn btn-outline-secondary btn-lg mb-3"
    id="like-btn-{{ product.id }}"
    data-product-id="{{ product.id }}">
    {% if user.is_authenticated %}
        {% if user in product.liked_by.all %}
            <i class="fas fa-heart" style="color: black;"></i>
        {% else %}
            <i class="far fa-heart"></i>
        {% endif %}
    {% else %}
        {% if product.id in request.session.liked_products %}
            <i class="fas fa-heart" style="color: black;"></i>
        {% else %}
            <i class="far fa-heart"></i>
        {% endif %}
    {% endif %}
</button>
\end{lstlisting}

---

\subsubsection{Skrypt \texttt{liked\_script.js}}
Skrypt obsługuje dynamiczną zmianę stanu przycisku reakcji oraz komunikację z widokiem \texttt{product\_like}.

\begin{lstlisting}[language=JavaScript, caption=Skrypt \texttt{liked\_script.js}]
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.like-btn').forEach(button => {
        button.addEventListener('click', function (e) {
            e.preventDefault();
            const productId = this.dataset.productId;

            fetch(`/product-like/${productId}/`, {
                method: 'GET',
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            })
                .then(response => response.json())
                .then(data => {
                    const button = document.getElementById(`like-btn-${productId}`);
                    const icon = button.querySelector('i');
                    if (data.liked) {
                        icon.classList.remove('far', 'fa-heart');
                        icon.classList.add('fas', 'fa-heart');
                        icon.style.color = 'black';
                        button.classList.add('liked');
                    } else {
                        icon.classList.remove('fas', 'fa-heart');
                        icon.classList.add('far', 'fa-heart');
                        icon.style.color = '';
                        button.classList.remove('liked');
                    }
                })
                .catch(error => console.error('Error:', error));
        });
    });
});
\end{lstlisting}

---

\subsubsection{Endpointy}

\paragraph{\texttt{urls.py}}
\begin{lstlisting}[language=Python, caption=Endpoint dla widoku \texttt{product\_like}]
path('product-like/<int:product_id>/', views.product_like, name="product_like"),
\end{lstlisting}

---

\subsubsection{Podsumowanie}
Funkcjonalność reakcji na produkty pozwala użytkownikom na wyrażenie opinii poprzez polubienia i oznaczenia jako niepolubione. Obsługuje zarówno użytkowników zalogowanych, jak i niezalogowanych. Zmiany w reakcjach są odzwierciedlane w czasie rzeczywistym dzięki wykorzystaniu AJAX.


% 
% Model Conversation and Messages
% 

\subsection{System wiadomości}

\subsubsection{Modele wiadomości i konwersacji}
System wiadomości opiera się na trzech modelach: \texttt{Conversation}, \texttt{Message} oraz \texttt{Profile}. Model \texttt{Conversation} odpowiada za przechowywanie informacji o konwersacjach między użytkownikami, \texttt{Message} przechowuje poszczególne wiadomości, a \texttt{Profile} umożliwia śledzenie ostatnio otwartej konwersacji dla użytkownika.

\begin{lstlisting}[language=Python, caption=Model \texttt{Conversation}]
class Conversation(models.Model):
    order = models.ForeignKey(
        Order, on_delete=models.CASCADE,
        related_name="conversations",
        null=True, blank=True
    )
    participants = models.ManyToManyField(User)
    created_at = models.DateTimeField(auto_now_add=True)
    is_admin_conversation = models.BooleanField(default=False)

    def __str__(self):
        return f"Conversation for Order #{self.order.id if self.order else 'General'} (Admin: {self.is_admin_conversation})"
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Model \texttt{Message}]
class Message(models.Model):
    conversation = models.ForeignKey(
        Conversation, on_delete=models.CASCADE,
        related_name='messages', null=True, blank=True
    )
    sender = models.ForeignKey(User, on_delete=models.CASCADE, null=True)
    content = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)

    def __str__(self):
        return f"Message from {self.sender} in Conversation #{self.conversation.id}"
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Model \texttt{Profile}]
class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    last_opened_conversation = models.ForeignKey(
        'Conversation', on_delete=models.SET_NULL,
        null=True, blank=True, related_name='last_opened_by'
    )
\end{lstlisting}

---

\subsubsection{Widoki i funkcje systemu wiadomości}

\paragraph{Widok \texttt{MessagesListView}}
Ten widok generuje listę konwersacji dla zalogowanego użytkownika i administratora. Konwersacje użytkownika dotyczą zamówień, a administrator widzi wszystkie konwersacje.

\begin{lstlisting}[language=Python, caption=Widok \texttt{MessagesListView}]
class MessagesListView(CategoriesMixin, LoginRequiredMixin, TemplateView):
    template_name = 'messages/messages_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        if user.is_superuser:
            conversations = Conversation.objects.filter(is_admin_conversation=False)
        else:
            conversations = Conversation.objects.filter(participants=user)

        context['conversations'] = [
            {
                'id': c.id,
                'order_id': c.order.id if c.order else None,
                'participant': c.participants.exclude(id=user.id).first().username if user.is_superuser else None
            }
            for c in conversations
        ]
        return context
\end{lstlisting}

---

\paragraph{Funkcja \texttt{load\_messages}}
Obsługuje ładowanie wiadomości z wybranej konwersacji, aktualizując również informacje o ostatnio otwartej konwersacji użytkownika.

\begin{lstlisting}[language=Python, caption=Funkcja \texttt{load\_messages}]
@login_required
def load_messages(request, conversation_id):
    conversation = get_object_or_404(Conversation, id=conversation_id, participants=request.user)
    profile = request.user.profile
    profile.last_opened_conversation = conversation
    profile.save()

    messages = conversation.messages.order_by('timestamp')
    return JsonResponse({
        'messages': [
            {'id': m.id, 'content': m.content, 'timestamp': m.timestamp.strftime('%H:%M'), 'sender': m.sender.username}
            for m in messages
        ]
    })
\end{lstlisting}

---

\paragraph{Funkcja \texttt{fetch\_new\_messages}}
Zapewnia odpytywanie o nowe wiadomości w danej konwersacji.

\begin{lstlisting}[language=Python, caption=Funkcja \texttt{fetch\_new\_messages}]
@login_required
def fetch_new_messages(request, conversation_id):
    last_message_id = int(request.GET.get('last_message_id', 0))
    conversation = get_object_or_404(Conversation, id=conversation_id, participants=request.user)

    new_messages = conversation.messages.filter(id__gt=last_message_id).order_by('timestamp')
    return JsonResponse({
        'new_messages': [
            {'id': m.id, 'content': m.content, 'timestamp': m.timestamp.strftime('%H:%M'), 'sender': m.sender.username}
            for m in new_messages
        ]
    })
\end{lstlisting}

---

\paragraph{Funkcja \texttt{send\_message}}
Pozwala użytkownikom na wysyłanie wiadomości w ramach wybranej konwersacji.

\begin{lstlisting}[language=Python, caption=Funkcja \texttt{send\_message}]
@login_required
def send_message(request):
    if request.method == 'POST':
        conversation_id = request.POST.get('conversation_id')
        content = request.POST.get('content')
        conversation = get_object_or_404(Conversation, id=conversation_id, participants=request.user)

        Message.objects.create(conversation=conversation, sender=request.user, content=content.strip())
        return JsonResponse({'message': 'Wiadomosc wyslana!'})
    return JsonResponse({'error': 'Nieprawidlowa metoda'}, status=400)
\end{lstlisting}

---

\subsubsection{Szablon \texttt{messages\_list.html}}

\begin{lstlisting}[language=HTML, caption=Szablon \texttt{messages\_list.html}]
<ul class="list-group list-group-flush">
    {% for conversation in conversations %}
        <li class="list-group-item" data-conversation-id="{{ conversation.id }}">
            {% if conversation.participant %}
                Konwersacja z {{ conversation.participant }}
            {% else %}
                Konwersacja ogolna
            {% endif %}
        </li>
    {% endfor %}
</ul>
<div id="chat-messages"></div>
\end{lstlisting}

---
\subsubsection{Skrypt \texttt{handle\_messages.js}}
Skrypt \texttt{handle\_messages.js} obsługuje logikę klienta dla systemu wiadomości. Został podzielony na kilka kluczowych funkcji odpowiadających za różne aspekty działania aplikacji:

---

\paragraph{1. Automatyczne ładowanie ostatnio otwartej konwersacji}
\begin{lstlisting}[language=JavaScript, caption=Automatyczne ładowanie ostatnio otwartej konwersacji]
const lastConversationId = $("#your_messages .list-group-item.active").data("conversation-id");
if (lastConversationId) {
    currentConversationId = lastConversationId;
    loadMessages(lastConversationId);
    startFetchingMessages();
}
\end{lstlisting}
Ten fragment kodu sprawdza, czy użytkownik ma ostatnio otwartą konwersację. Jeśli tak, to automatycznie ją ładuje i uruchamia cykliczne odpytywanie o nowe wiadomości.

---

\paragraph{2. Obsługa zmiany konwersacji}
\begin{lstlisting}[language=JavaScript, caption=Obsługa zmiany konwersacji]
$(".list-group-item").click(function () {
    $(".list-group-item").removeClass("active");
    $(this).addClass("active");

    currentConversationId = $(this).attr("data-conversation-id");
    $("#chat-title").text($(this).text());

    loadMessages(currentConversationId);
    stopFetchingMessages();
    startFetchingMessages();
    saveLastOpenedConversation(currentConversationId);
});
\end{lstlisting}
Po kliknięciu w konwersację na liście:
\begin{itemize}
    \item Zmieniana jest aktywna konwersacja.
    \item Ładowane są wiadomości dla wybranej konwersacji.
    \item Rozpoczyna się cykliczne odpytywanie serwera o nowe wiadomości.
    \item Zapisywana jest informacja o ostatnio otwartej konwersacji.
\end{itemize}

---

\paragraph{3. Funkcja \texttt{loadMessages}}
\begin{lstlisting}[language=JavaScript, caption=Funkcja \texttt{loadMessages}]
function loadMessages(conversationId) {
    if (!conversationId) return;

    $.ajax({
        url: `/messages/${conversationId}/load/`,
        method: "GET",
        success: function (data) {
            $("#chat-messages").empty();
            if (data.messages.length > 0) {
                data.messages.forEach((message) => {
                    const messageHtml = `
                        <div class="message ${message.sender === loggedInUser ? "message-sent" : "message-received"}">
                            <p>${message.content}</p>
                            <span class="timestamp">${message.timestamp}</span>
                        </div>`;
                    $("#chat-messages").append(messageHtml);
                });
                $("#chat-messages").scrollTop($("#chat-messages")[0].scrollHeight);
            } else {
                $("#chat-messages").html('<p class="text-muted">Brak wiadomosci w tej konwersacji.</p>');
            }
        },
        error: function () {
            alert("Nie udalo sie zaladowac wiadomosci.");
        },
    });
}
\end{lstlisting}
Ta funkcja ładuje wiadomości dla danej konwersacji i wyświetla je w odpowiednim formacie:
\begin{itemize}
    \item Wyróżnia wiadomości wysłane przez użytkownika (\texttt{message-sent}) i odebrane (\texttt{message-received}).
    \item Jeśli nie ma wiadomości, wyświetlany jest komunikat.
    \item Przewija widok wiadomości na dół po załadowaniu.
\end{itemize}

---

\paragraph{4. Funkcja \texttt{saveLastOpenedConversation}}
\begin{lstlisting}[language=JavaScript, caption=Funkcja \texttt{saveLastOpenedConversation}]
function saveLastOpenedConversation(conversationId) {
    $.ajax({
        url: `/messages/${conversationId}/save-last-opened/`,
        method: "POST",
        headers: {
            "X-CSRFToken": $("input[name=csrfmiddlewaretoken]").val(),
        },
        success: function () {
            console.log(`Zapisano ostatnio otwarta konwersacje: ${conversationId}`);
        },
        error: function () {
            console.error("Nie udalo sie zapisac ostatnio otwartej konwersacji.");
        },
    });
}
\end{lstlisting}
Funkcja zapisuje na serwerze informację o ostatnio otwartej konwersacji. Jest to przydatne, aby użytkownik mógł automatycznie wrócić do swojej ostatniej rozmowy.

---

\paragraph{5. Funkcja \texttt{fetchNewMessages}}
\begin{lstlisting}[language=JavaScript, caption=Funkcja \texttt{fetchNewMessages}]
function fetchNewMessages() {
    if (!currentConversationId || isFetching) return;

    isFetching = true;

    $.ajax({
        url: `/messages/${currentConversationId}/fetch-new/`,
        method: "GET",
        data: { last_message_id: lastMessageId },
        success: function (data) {
            if (data.new_messages.length > 0) {
                data.new_messages.forEach((message) => {
                    const messageHtml = `
                    <div class="message ${message.sender === loggedInUser ? "message-sent" : "message-received"}">
                        <p>${message.content}</p>
                        <span class="timestamp">${message.timestamp}</span>
                    </div>`;
                    $("#chat-messages").append(messageHtml);
                    lastMessageId = message.id;
                });
                $("#chat-messages").scrollTop($("#chat-messages")[0].scrollHeight);
            }
        },
        complete: function () {
            isFetching = false;
        },
    });
}
\end{lstlisting}
Funkcja:
\begin{itemize}
    \item Pobiera nowe wiadomości dla aktywnej konwersacji.
    \item Aktualizuje widok wiadomości w czasie rzeczywistym.
    \item Przewija widok wiadomości na dół.
\end{itemize}

---

\paragraph{6. Funkcja \texttt{startFetchingMessages} i \texttt{stopFetchingMessages}}
\begin{lstlisting}[language=JavaScript, caption=Funkcje do zarządzania cyklicznym odpytywaniem]
function startFetchingMessages() {
    if (!fetchInterval) {
        fetchInterval = setInterval(fetchNewMessages, 1000);
    }
}

function stopFetchingMessages() {
    if (fetchInterval) {
        clearInterval(fetchInterval);
        fetchInterval = null;
    }
}
\end{lstlisting}
Te funkcje zarządzają cyklicznym odpytywaniem serwera:
\begin{itemize}
    \item \texttt{startFetchingMessages} uruchamia odpytywanie co sekundę.
    \item \texttt{stopFetchingMessages} zatrzymuje proces odpytywania.
\end{itemize}

---

\paragraph{7. Obsługa wysyłania wiadomości}
\begin{lstlisting}[language=JavaScript, caption=Wysyłanie wiadomości]
$("#message-form").submit(function (e) {
    e.preventDefault();
    const content = $("#message-input").val().trim();
    if (!content) return;

    $.ajax({
        url: `/messages/send/`,
        method: "POST",
        data: {
            conversation_id: currentConversationId,
            content: content,
            csrfmiddlewaretoken: $("input[name=csrfmiddlewaretoken]").val(),
        },
        success: function () {
            $("#message-input").val("");
            fetchNewMessages();
        },
    });
});
\end{lstlisting}
Funkcja obsługuje wysyłanie wiadomości przez użytkownika:
\begin{itemize}
    \item Pobiera treść z pola tekstowego.
    \item Wysyła wiadomość do serwera.
    \item Wymusza odświeżenie widoku wiadomości.
\end{itemize}

---

\subsubsection{Podsumowanie}
Skrypt \texttt{handle\_messages.js} umożliwia obsługę systemu wiadomości w czasie rzeczywistym. Kluczowe funkcje zapewniają ładowanie wiadomości, odpytywanie o nowe wiadomości oraz ich wysyłanie, tworząc dynamiczny interfejs użytkownika.

---

\subsubsection{Podsumowanie}
System wiadomości umożliwia dwukierunkową komunikację między użytkownikami a administratorem. Obsługuje tworzenie, przeglądanie i zarządzanie wiadomościami w czasie rzeczywistym dzięki wykorzystaniu AJAX.


% 
% Model UserProductVisibility
% 


\section{Model \texttt{UserProductVisibility}}
\subsection{Opis klasy}
Model \texttt{UserProductVisibility} jest używany do rejestrowania widoczności produktów przez użytkowników w systemie. Rejestrowanie widoczności pozwala na analizę zainteresowań użytkowników, co może być wykorzystane w personalizacji rekomendacji produktowych.

\paragraph{Pola klasy:}
\begin{itemize}
    \item \texttt{user}: (Relacja z modelem \texttt{User}) Użytkownik, który obejrzał produkt.
    \item \texttt{product}: (Relacja z modelem \texttt{Product}) Produkt, który został wyświetlony użytkownikowi.
    \item \texttt{view\_date}: Data i czas, kiedy produkt został wyświetlony użytkownikowi.
\end{itemize}

\paragraph{Metody klasy:}
\begin{itemize}
    \item \texttt{\_\_str\_\_}: Zwraca reprezentację tekstową w formacie: \texttt{username viewed product\_name on view\_date}.
\end{itemize}

\label{ProductDetailView_product_visibility}
\subsection{Rejestracja widoczności w \texttt{ProductDetailView}}
Poniżej znajduje się kluczowy fragment kodu z \texttt{ProductDetailView}, który rejestruje widoczność produktu:

\begin{lstlisting}[language=Python]
if request.user.is_authenticated:
    if not UserProductVisibility.objects.filter(
        user=request.user, 
        product=product, 
        view_date__gte=one_hour_ago
    ).exists():
        UserProductVisibility.objects.create(
            user=request.user, 
            product=product, 
            view_date=timezone.now()
        )
else:
    if 'product_visibility' not in request.session:
        request.session['product_visibility'] = []

    session_entries = request.session['product_visibility']
    if not any(
        entry['product'] == product.id and 
        datetime.fromisoformat(entry['view_date']) >= one_hour_ago
        for entry in session_entries
    ):
        session_entries.append({
            'product': product.id,
            'view_date': timezone.now().isoformat()
        })
    request.session.modified = True
\end{lstlisting}

\paragraph{Analiza:}
\begin{itemize}
    \item Dla zalogowanych użytkowników:
    \begin{itemize}
        \item Sprawdzane jest, czy widoczność danego produktu została już zarejestrowana w ciągu ostatniej godziny.
        \item Jeśli nie, tworzony jest nowy wpis w modelu \texttt{UserProductVisibility}.
    \end{itemize}
    \item Dla niezalogowanych użytkowników:
    \begin{itemize}
        \item Widoczność produktu jest przechowywana w sesji, jako lista obiektów zawierających identyfikator produktu i czas wyświetlenia.
    \end{itemize}
\end{itemize}

\subsection{Rola modelu w algorytmie rekomendacyjnym}
Model \texttt{UserProductVisibility} odgrywa kluczową rolę w algorytmie rekomendacyjnym, pomagając w identyfikacji produktów, które były oglądane przez użytkowników. Fragment kodu z algorytmu rekomendacyjnego:

\begin{lstlisting}[language=Python]
user_viewed_products = UserProductVisibility.objects.filter(
    user=user,
    view_date__gte=seven_days_ago
)

# Dodaj punkty za produkty wyswietlone po poleceniu
for product in user_viewed_products:
    similar_products = get_similar_products(product.product)  # Funkcja generujaca podobne produkty
    for similar_product in similar_products:
        product_scores[similar_product.id] += WEIGHT_VIEVED_SIMILAR_PRODUCT
\end{lstlisting}

\paragraph{Analiza:}
\begin{itemize}
    \item \texttt{UserProductVisibility} pozwala na identyfikację produktów wyświetlonych przez użytkownika w ciągu ostatnich 7 dni.
    \item Na podstawie tych danych algorytm:
    \begin{itemize}
        \item Przyznaje dodatkowe punkty produktom podobnym do oglądanych.
        \item Umożliwia personalizację rekomendacji na podstawie zainteresowań użytkownika.
    \end{itemize}
\end{itemize}

\subsection{Podsumowanie}
Model \texttt{UserProductVisibility} pełni funkcję rejestratora zainteresowań użytkowników, umożliwiając systemowi rekomendacyjnemu bardziej precyzyjne dostosowanie poleceń produktów. Dzięki połączeniu z innymi źródłami danych (np. polubieniami, zakupami) model wspiera budowę zaawansowanego mechanizmu rekomendacji w aplikacji.


% 
% Model UserCategoryVisibility 
% 


\section{Model UserCategoryVisibility}

\subsection{Opis Modelu}
\begin{lstlisting}[language=Python]
class UserCategoryVisibility(models.Model):
    user = models.ForeignKey('User', on_delete=models.CASCADE)
    category = models.ForeignKey('Category', on_delete=models.CASCADE)
    view_date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.username} viewed {self.category.name} on {self.view_date}"
\end{lstlisting}

Model \texttt{UserCategoryVisibility} przechowuje informacje o kategoriach produktów wyświetlonych przez użytkowników. Każdy wpis rejestruje użytkownika, kategorię oraz datę wyświetlenia. Dane te są wykorzystywane w celu:
\begin{itemize}
    \item śledzenia interakcji użytkownika z kategoriami produktów,
    \item zasilania algorytmu rekomendacyjnego,
    \item dostosowywania oferty i filtrów widocznych w aplikacji.
\end{itemize}

\subsection{Wykorzystanie w Widoku Kategorii}
Model jest wykorzystywany w klasie \texttt{CategoryProductsView}. Kluczowy fragment kodu:\par
\begin{lstlisting}[language=Python]
if not max_price and not min_price and not sort_by:
    if self.request.user.is_authenticated:
        if not UserCategoryVisibility.objects.filter(user=self.request.user, category=category,
                                                     view_date__gte=one_hour_ago).exists():
            UserCategoryVisibility.objects.create(user=self.request.user, category=category,
                                                  view_date=timezone.now())
    else:
        if 'category_visibility' not in self.request.session:
            self.request.session['category_visibility'] = []

        session_entries = self.request.session['category_visibility']
        if not any(entry['category'] == category.id and datetime.fromisoformat(entry['view_date']) >= one_hour_ago
                   for entry in session_entries):
            session_entries.append({
                'category': category.id,
                'view_date': timezone.now().isoformat()
            })

        self.request.session.modified = True
\end{lstlisting}

\subsubsection{Logika}
\begin{itemize}
    \item \textbf{Użytkownicy zalogowani:} Jeśli użytkownik zalogowany wyświetla kategorię, aplikacja sprawdza, czy istnieje wpis \texttt{UserCategoryVisibility} dla tej kategorii z ostatniej godziny. Jeśli nie, tworzony jest nowy wpis.
    \item \textbf{Użytkownicy niezalogowani:} Informacje o widoczności kategorii są przechowywane w sesji. Jeśli wpis dla danej kategorii nie istnieje (lub jest starszy niż godzina), dodawany jest nowy wpis do listy \texttt{category\_visibility}.
\end{itemize}

Celem tej implementacji jest uniknięcie wielokrotnego dodawania danych widoczności kategorii w krótkich odstępach czasu, co mogłoby sztucznie zwiększyć ich znaczenie w analizie.

\subsection{Wykorzystanie w Algorytmie Rekomendacyjnym}
Model \texttt{UserCategoryVisibility} jest używany w funkcji \texttt{get\_recommended\_products} w celu zwiększenia punktacji produktów w często wyświetlanych kategoriach. Kluczowy fragment kodu:
\begin{lstlisting}[language=Python]
viewed_categories = (
    UserCategoryVisibility.objects.filter(
        user=user,
        view_date__gte=seven_days_ago
    )
    .values('category_id')
    .annotate(view_count=Count('id'))
)

for entry in viewed_categories:
    category_id = entry['category_id']
    view_count = entry['view_count']

    category_products = Product.objects.filter(categories__id=category_id).distinct()
    for product in category_products:
        product_scores[product.id] += WEIGHT_CATEGORY_VISIBILITY * view_count
\end{lstlisting}

\subsubsection{Logika}
\begin{itemize}
    \item \textbf{Obliczanie liczby wyświetleń:} Funkcja oblicza liczbę wyświetleń każdej kategorii przez użytkownika w ciągu ostatnich siedmiu dni.
    \item \textbf{Punktacja produktów:} Dla każdej kategorii produkty należące do niej otrzymują dodatkowe punkty, proporcjonalne do liczby wyświetleń kategorii oraz wagi \texttt{WEIGHT\_CATEGORY\_VISIBILITY}.
\end{itemize}

\subsection{Cel Modelu}
\begin{itemize}
    \item \textbf{Śledzenie preferencji użytkownika:} Dane z modelu są wykorzystywane do analizy preferencji użytkowników na podstawie ich aktywności w aplikacji.
    \item \textbf{Dostosowanie rekomendacji:} Widoczność kategorii wpływa na ranking produktów w algorytmie rekomendacyjnym, co pozwala lepiej dopasować ofertę do użytkownika.
    \item \textbf{Optymalizacja sesji:} Dla użytkowników niezalogowanych dane o widoczności kategorii są przechowywane w sesji, co pozwala zachować spójność doświadczeń użytkownika bez wymogu rejestracji.
\end{itemize}


% 
% Model RecommendedProducts | UserRecommendedProductInteraction
% 
\section{Model \texttt{RecommendedProducts}}

\begin{lstlisting}[language=Python]
class RecommendedProducts(models.Model):
    user = models.ForeignKey('User', on_delete=models.CASCADE, null=True, blank=True)
    products = models.ManyToManyField(Product, related_name='recomended_products')
    added_at = models.DateTimeField(auto_now_add=True)
\end{lstlisting}

\subsection*{Opis modelu}
Model \texttt{RecommendedProducts} przechowuje informacje o produktach rekomendowanych dla konkretnego użytkownika. W tabeli tej znajdują się następujące pola:
\begin{itemize}
    \item \textbf{user} -- klucz obcy do modelu \texttt{User}, który wskazuje użytkownika, dla którego wygenerowano rekomendacje.
    \item \textbf{products} -- pole typu \texttt{ManyToManyField}, które zawiera listę rekomendowanych produktów.
    \item \textbf{added\_at} -- data i czas wygenerowania rekomendacji.
\end{itemize}

\subsection*{Logika użycia}
Model ten jest wykorzystywany w algorytmie rekomendacyjnym do zapisywania listy rekomendowanych produktów dla użytkownika. 

Fragment kodu w widoku:

\begin{lstlisting}[language=Python]
recommended_products_instance, created = RecommendedProducts.objects.get_or_create(user=user)
recommended_products_instance.products.set(recommended_products)
recommended_products_instance.added_at = timezone.now()
recommended_products_instance.save()
\end{lstlisting}

\paragraph{Opis działania:}
\begin{itemize}
    \item Jeśli instancja \texttt{RecommendedProducts} dla użytkownika istnieje, zostaje zaktualizowana o nową listę produktów.
    \item Jeśli instancja nie istnieje, jest tworzona i wypełniana nowymi rekomendacjami.
    \item Pole \texttt{added\_at} zapisuje czas wygenerowania rekomendacji, co pozwala śledzić ich aktualność.
\end{itemize}

---

\section{Model \texttt{UserRecommendedProductInteraction}}

\begin{lstlisting}[language=Python]
class UserRecommendedProductInteraction(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    interaction_type = models.CharField(
        max_length=20,
        choices=[('view', 'View'), ('like', 'Like'), ('buy', 'Buy')]
    )
    interaction_date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user} {self.interaction_type} {self.product} on {self.interaction_date}"
\end{lstlisting}

\subsection*{Opis modelu}
Model \texttt{UserRecommendedProductInteraction} zapisuje interakcje użytkownika z produktami, które zostały mu zarekomendowane. 

\paragraph{Pola modelu:}
\begin{itemize}
    \item \textbf{user} -- klucz obcy do modelu \texttt{User}, wskazuje użytkownika wykonującego interakcję.
    \item \textbf{product} -- klucz obcy do modelu \texttt{Product}, określa produkt, z którym użytkownik wchodzi w interakcję.
    \item \textbf{interaction\_type} -- typ interakcji (\texttt{'view'}, \texttt{'like'}, \texttt{'buy'}).
    \item \textbf{interaction\_date} -- data i czas interakcji.
\end{itemize}

\subsection*{Logika użycia}
Model ten jest wykorzystywany w algorytmie rekomendacyjnym do rejestrowania interakcji użytkownika z rekomendowanymi produktami.

Fragment kodu:

\begin{lstlisting}[language=Python]
# Zapisz interakcje z polecanymi produktami
for product_id in viewed_products:
    UserRecommendedProductInteraction.objects.create(
        user=user,
        product_id=product_id,
        interaction_type='view'
    )

for product_id in liked_products:
    UserRecommendedProductInteraction.objects.create(
        user=user,
        product_id=product_id,
        interaction_type='like'
    )

for product_id in purchased_products:
    UserRecommendedProductInteraction.objects.create(
        user=user,
        product_id=product_id,
        interaction_type='buy'
    )
\end{lstlisting}

\paragraph{Opis działania:}
\begin{itemize}
    \item Dla każdego produktu zarekomendowanego użytkownikowi zapisuje się interakcję (\texttt{view}, \texttt{like}, \texttt{buy}).
    \item Każda interakcja zawiera informacje o użytkowniku, produkcie, typie interakcji oraz czasie jej wykonania.
    \item Dane te mogą być wykorzystane do analizy skuteczności rekomendacji i personalizacji przyszłych sugestii.
\end{itemize}

---

\section{Integracja z widokiem głównym}
W widoku \texttt{HomePageView} oba modele są używane do generowania listy produktów rekomendowanych dla użytkownika.

\begin{lstlisting}[language=Python]
def get_queryset(self):
    if self.request.user.is_authenticated:
        queryset = get_recommended_products(self.request.user)
        if not queryset:
            queryset = Product.objects.order_by('?')[:10]
    else:
        queryset = get_recommended_products_from_session(self.request.session)
    return queryset
\end{lstlisting}

\paragraph{Opis działania:}
\begin{itemize}
    \item Metoda \texttt{get\_recommended\_products} zwraca listę produktów na podstawie zapisanych interakcji i modeli rekomendacyjnych.
    \item W przypadku braku rekomendacji dla zalogowanego użytkownika, system zwraca losowe produkty.
    \item Dla niezalogowanych użytkowników rekomendacje generowane są na podstawie danych z sesji.
\end{itemize}

\section{Główny szablon \texttt{index.html}}

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 shrink-to-fit=no"/>
    <title>
        {% block title %}KMG{% endblock %}
    </title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/style.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/header.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/categories.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/product.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/like-cart-btn.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/mainPage/main_banner.css' %}"/>
    <link rel="stylesheet" href="{% static 'css/mainPage/slider.css' %}"/>
</head>
<body>
    {% include 'header.html' %}
    {% include 'homePage/main_banner.html' %}
    {% include 'homePage/slider_recommended.html' %}
    <div style="margin: 0 auto; height: 50px"></div>
    {% include 'homePage/slider_favorites.html' %}

    <!--Messages/Errors popup-->
    {% if messages %}
        {% for message in messages %}
            <div class="alert alert-success position-fixed bottom-0 end-0 m-3" id="messagePopUp">
                {{ message }}
            </div>
        {% endfor %}
    {% endif %}

    <script id="liked-product-ids" type="application/json">
        {{ liked_product_ids|safe }}
    </script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="{% static 'js/script.js' %}"></script>
    <script src="{% static 'js/liked_script.js' %}"></script>
    <script src="{% static 'js/home_page.js' %}"></script>
</body>
</html>
\end{lstlisting}

\subsection*{Opis szablonu}
Główny szablon \texttt{index.html} integruje komponenty witryny, takie jak nagłówek, baner główny oraz sekcje z rekomendacjami i ulubionymi produktami. 

\paragraph{Główne elementy:}
\begin{itemize}
    \item \textbf{Nagłówki:} Linki do stylów CSS i ikon.
    \item \textbf{Dynamiczne sekcje:} Komponenty takie jak \texttt{main\_banner.html}, \texttt{slider\_recommended.html}, oraz \texttt{slider\_favorites.html}, które wyświetlają dynamicznie generowane dane.
    \item \textbf{Wiadomości systemowe:} Obsługa wiadomości (np. błędów lub sukcesów).
    \item \textbf{Stopka:} Informacje kontaktowe i prawa autorskie.
    \item \textbf{Skrypty JS:} Funkcje interaktywne takie jak obsługa polubień produktów.
\end{itemize}



% \subsection{Środowisko programistyczne}
% \textit{Opis instalacji i konfiguracji niezbędnego środowiska programistycznego potrzebnego do ewentualnej dalszej pracy deweloperskiej z projektem (system operacyjny, wszelkie niezbędne narzędzia, biblioteki itp. wraz z sugerowanymi/minimalnymi ich wersjami).}


\section{Środowisko programistyczne}

\subsection{System operacyjny i konfiguracja środowiska}

Projekt został opracowany i przetestowany w systemie operacyjnym Windows 10. Minimalne wymagania sprzętowe to komputer z zainstalowanym Pythonem w wersji 3.9 lub wyższej.

\subsection{Instalacja środowiska}

Środowisko programistyczne można skonfigurować zgodnie z poniższymi krokami:
\begin{enumerate}
    \item Pobierz i zainstaluj \textbf{Python} w wersji 3.9 lub wyższej, dostępny na stronie \url{https://www.python.org/downloads/}.
    \item W terminalu utwórz i aktywuj wirtualne środowisko:
    \begin{lstlisting}[language=bash]
    python -m venv env
    source env/Scripts/activate  # Windows
    \end{lstlisting}
    \item Zainstaluj wymagane biblioteki:
    \begin{lstlisting}[language=bash]
    pip install -r Docs/requirements.txt
    \end{lstlisting}
    Kluczowe biblioteki używane w projekcie to:
    \begin{itemize}
        \item \textbf{Django} (5.1.2) - framework do budowy aplikacji webowych,
        \item \textbf{selenium} (4.27.1) - do automatyzacji pobierania danych,
        \item \textbf{pillow} (11.0.0) - do przetwarzania obrazów,
        \item \textbf{python-dotenv} (1.0.1) - do zarządzania zmiennymi środowiskowymi.
    \end{itemize}
\end{enumerate}

\subsection{Przygotowanie bazy danych}

Projekt korzysta z bazy danych SQLite, która jest domyślnie wspierana przez Django. W celu skonfigurowania bazy danych należy wykonać poniższe kroki:
\begin{enumerate}
    \item W terminalu wykonaj migracje:
    \begin{lstlisting}[language=bash]
    python manage.py makemigrations
    python manage.py migrate
    \end{lstlisting}
    \item Opcjonalnie, utwórz użytkownika administratora:
    \begin{lstlisting}[language=bash]
    python manage.py createsuperuser
    \end{lstlisting}
\end{enumerate}

\subsection{Seedowanie danych testowych}

Aby załadować dane testowe do bazy danych, należy uruchomić następujące skrypty w podanej kolejności:
\begin{enumerate}
    \item \texttt{next\_products\_seed/import\_next\_json\_to\_database.py}
    \item \texttt{next\_products\_seed/next\_product\_seed.py}
    \item \texttt{next\_products\_seed/download\_image\_for\_products.py}
    \item \texttt{media/resizer.py}
\end{enumerate}

Każdy z powyższych skryptów jest odpowiedzialny za różne etapy seedowania danych, takie jak:
\begin{itemize}
    \item importowanie danych produktów,
    \item generowanie szczegółowych danych o produktach,
    \item pobieranie obrazów produktów,
    \item zmiana rozmiarów obrazów.
\end{itemize}

\subsection{Uruchamianie serwera}

Po wykonaniu wszystkich kroków przygotowawczych, serwer można uruchomić za pomocą polecenia:
\begin{lstlisting}[language=bash]
python manage.py runserver
\end{lstlisting}
Aplikacja będzie dostępna pod adresem \url{http://127.0.0.1:8000/}.

\subsection{Skrypty pomocnicze}

Projekt zawiera również skrypt automatyzujący konfigurację środowiska i uruchamianie projektu:
\begin{lstlisting}[language=bash]
bash init_project.sh
\end{lstlisting}
Skrypt ten wykonuje następujące kroki:
\begin{itemize}
    \item tworzy wirtualne środowisko i instaluje zależności,
    \item wykonuje migracje bazy danych,
    \item uruchamia serwer Django.
\end{itemize}
\```

Powyższy dokument przedstawia wymagania środowiskowe oraz kroki potrzebne do uruchomienia i dalszej pracy z projektem. Jeśli masz dodatkowe pytania, chętnie pomogę!

\newpage
\addcontentsline{toc}{section}{Lista Fragmentów Kodów}
\lstlistoflistings
\renewcommand\refname{Literatura (jeżeli wymagana)}
\bibliography{references}
\addcontentsline{toc}{section}{Literatura}
% --------------------------------------------------------------------
%%%%%%% odkomentować gdy bibliografia ma być wewnątrz dokumentu
% --------------------------------------------------------------------
%\begin{thebibliography}{11}
%
%\addcontentsline{toc}{section}{Literatura}
%
%\bibitem{ZAN}
%C. Zannoni and P. Pasini, 
%\emph{Advances in the Computer Simulatons of Liquid Crystals}, Kluwer Academic Publishers, 2000.
%
%\end{thebibliography}

\end{document}

